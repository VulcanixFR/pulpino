diff --git a/controller.sv b/controller.sv
index 449858d..9ef9f8e 100644
--- a/controller.sv
+++ b/controller.sv
@@ -23,6 +23,10 @@
 // Description:    Main CPU controller of the processor                       //
 //                                                                            //
 ////////////////////////////////////////////////////////////////////////////////
+// Ajout dans ce fichier de "branch_taken_ex_i_tag" et "pc_set_o_tag", à voir leur utilité pour nous
+// Y a moyen que ce ne soient que pour le tag de pc, auquel cas on n'a pas besoin d'y toucher
+
+`include "riscv_config.sv"
 
 import riscv_defines::*;
 
@@ -127,6 +131,12 @@ module riscv_controller
   output logic        perf_jump_o,                // we are executing a jump instruction   (j, jr, jal, jalr)
   output logic        perf_jr_stall_o,            // stall due to jump-register-hazard
   output logic        perf_ld_stall_o             // stall due to load-use-hazard
+
+`ifdef DIFT
+  ,
+  input  logic        branch_taken_ex_i_tag,
+  output logic        pc_set_o_tag
+`endif
 );
 
   // FSM state encoding
@@ -174,6 +184,9 @@ module riscv_controller
 
     pc_mux_o         = PC_BOOT;
     pc_set_o         = 1'b0;
+`ifdef DIFT
+    pc_set_o_tag     = 1'b0;
+`endif
     jump_done        = jump_done_q;
 
     ctrl_fsm_ns      = ctrl_fsm_cs;
@@ -207,7 +220,9 @@ module riscv_controller
         instr_req_o   = 1'b1;
         pc_mux_o      = PC_BOOT;
         pc_set_o      = 1'b1;
-
+`ifdef DIFT
+        pc_set_o_tag  = 1'b1;
+`endif
         ctrl_fsm_ns = FIRST_FETCH;
       end
 
@@ -278,8 +293,11 @@ module riscv_controller
 
             // if there is a jr stall, wait for it to be gone
             if ((~jr_stall_o) && (~jump_done_q)) begin
-              pc_set_o    = 1'b1;
-              jump_done   = 1'b1;
+              pc_set_o     = 1'b1;
+`ifdef DIFT
+              pc_set_o_tag = 1'b1;
+`endif
+              jump_done    = 1'b1;
             end
 
             // we don't have to change our current state here as the prefetch
@@ -290,6 +308,9 @@ module riscv_controller
             if (exc_req_i) begin
               pc_mux_o      = PC_EXCEPTION;
               pc_set_o      = 1'b1;
+`ifdef DIFT
+              pc_set_o_tag  = 1'b1;
+`endif
               exc_ack_o     = 1'b1;
 
               halt_id_o     = 1'b1; // we don't want to propagate this instruction to EX
@@ -365,6 +386,13 @@ module riscv_controller
             ctrl_fsm_ns = DBG_SIGNAL;
           end
         end
+
+`ifdef DIFT
+        if (branch_taken_ex_i_tag) begin
+          pc_set_o_tag  = 1'b1;
+        end
+`endif
+
       end
 
       // a branch was in ID when a debug trap is hit
@@ -378,6 +406,12 @@ module riscv_controller
           pc_set_o = 1'b1;
         end
 
+`ifdef DIFT
+        if (branch_taken_ex_i_tag) begin
+          pc_set_o_tag = 1'b1;
+        end
+`endif
+
         ctrl_fsm_ns = DBG_SIGNAL;
       end
 
diff --git a/cs_registers.sv b/cs_registers.sv
index 8de09fa..c5d4de0 100644
--- a/cs_registers.sv
+++ b/cs_registers.sv
@@ -22,6 +22,9 @@
 //                 RiscV draft priviledged instruction set spec (v1.7)        //
 //                                                                            //
 ////////////////////////////////////////////////////////////////////////////////
+// Ajout des registres TPR et TCR, y faudra qu'on vienne y rajouter THR
+
+`include "riscv_config.sv"
 
 import riscv_defines::*;
 
@@ -56,7 +59,13 @@ module riscv_cs_registers
   // Interrupts
   output logic        irq_enable_o,
   output logic [31:0] mepc_o,
-
+`ifdef DIFT   //Définition en tant que sortie des registres TPR et TCR
+  output logic [31:0] tpr_o,
+  output logic [31:0] tcr_o,
+`ifdef DIFT_H
+  output logic [31:0] thr_o,
+`endif
+`endif
   input  logic [31:0] pc_if_i,
   input  logic [31:0] pc_id_i,
   input  logic [31:0] pc_ex_i,
@@ -131,11 +140,18 @@ module riscv_cs_registers
   logic [ 0:0] mstatus_q, mstatus_n;
   logic [ 5:0] exc_cause, exc_cause_n;
 
+`ifdef DIFT   // Variables pour la machine à états je pense
+  logic [31:0] tpr_q, tpr_n;
+  logic [31:0] tcr_q, tcr_n;
+`ifdef DIFT_H
+  logic [31:0] thr_q, thr_n;
+`endif
+`endif
 
   ////////////////////////////////////////////
   //   ____ ____  ____    ____              //
   //  / ___/ ___||  _ \  |  _ \ ___  __ _   //
-  // | |   \___ \| |_) | | |_) / _ \/ _` |  //   
+  // | |   \___ \| |_) | | |_) / _ \/ _` |  //
   // | |___ ___) |  _ <  |  _ <  __/ (_| |  //
   //  \____|____/|_| \_\ |_| \_\___|\__, |  //
   //                                |___/   //
@@ -170,6 +186,14 @@ module riscv_cs_registers
       12'h7B5: csr_rdata_int = hwlp_end_i[1];
       12'h7B6: csr_rdata_int = hwlp_cnt_i[1];
 
+    `ifdef DIFT // Lecture des valeurs des registres du DIFT
+      12'h700: csr_rdata_int = tpr_q;
+      12'h701: csr_rdata_int = tcr_q;
+    `ifdef DIFT_H
+      12'h702: csr_rdata_int = thr_q;
+    `endif
+    `endif
+
       12'h7C0: csr_rdata_int = {29'b0, 2'b11, mestatus_q};
     endcase
   end
@@ -185,6 +209,14 @@ module riscv_cs_registers
     hwlp_we_o    = '0;
     hwlp_regid_o = '0;
 
+  `ifdef DIFT   // Mise à jour de la machine à états
+    tpr_n = tpr_q;
+    tcr_n = tcr_q;
+  `ifdef DIFT_H
+    thr_n = thr_q;
+  `endif
+  `endif
+
     case (csr_addr_i)
       // mstatus: IE bit
       12'h300: if (csr_we_int) mstatus_n = csr_wdata_int[0];
@@ -202,6 +234,14 @@ module riscv_cs_registers
       12'h7B5: if (csr_we_int) begin hwlp_we_o = 3'b010; hwlp_regid_o = 1'b1; end
       12'h7B6: if (csr_we_int) begin hwlp_we_o = 3'b100; hwlp_regid_o = 1'b1; end
 
+    `ifdef DIFT   // J'imagine que c'est l'update des registres TCR et TPR dans le CSR
+      12'h700: if (csr_we_int) tpr_n = csr_wdata_int;
+      12'h701: if (csr_we_int) tcr_n = csr_wdata_int;
+    `ifdef DIFT_H
+      12'h702: if (csr_we_int) thr_n = csr_wdata_int;
+    `endif
+    `endif
+
       // mestatus: machine exception status
       12'h7C0: if (csr_we_int) mestatus_n = csr_wdata_int[0];
     endcase
@@ -268,6 +308,13 @@ module riscv_cs_registers
   assign irq_enable_o = mstatus_q[0];
   assign mepc_o       = mepc_q;
 
+`ifdef DIFT
+  assign tpr_o = tpr_q;
+  assign tcr_o = tcr_q;
+`ifdef DIFT_H
+  assign thr_o = thr_q;
+`endif
+`endif
 
   // actual registers
   always_ff @(posedge clk, negedge rst_n)
@@ -278,6 +325,15 @@ module riscv_cs_registers
       mepc_q     <= '0;
       mestatus_q <= '0;
       exc_cause  <= '0;
+
+    `ifdef DIFT //Politiques de propagation et de check des tags de base
+      tpr_q = 32'b00000000000000001010100010100010;
+      tcr_q = 32'b00000000001101000001100000000000;
+    `ifdef DIFT_H
+      thr_q = 32'b00000000000000000000000000000011;
+    `endif
+    `endif
+
     end
     else
     begin
@@ -288,6 +344,15 @@ module riscv_cs_registers
       mestatus_q <= mestatus_n;
 
       exc_cause  <= exc_cause_n;
+
+    `ifdef DIFT // Mise à jour du CSR
+      tpr_q = tpr_n;
+      tcr_q = tcr_n;
+    `ifdef DIFT_H
+      thr_q = thr_n;
+    `endif
+    `endif
+
     end
   end
 
diff --git a/decoder.sv b/decoder.sv
index 3144e21..1c92b51 100644
--- a/decoder.sv
+++ b/decoder.sv
@@ -24,6 +24,8 @@
 //                                                                            //
 ////////////////////////////////////////////////////////////////////////////////
 
+`include "riscv_config.sv"
+
 import riscv_defines::*;
 
 module riscv_decoder
@@ -115,6 +117,8 @@ module riscv_decoder
 
   logic [1:0] csr_op;
 
+  // [DEBUG] DIFT
+  logic is_dift_i;
 
   /////////////////////////////////////////////
   //   ____                     _            //
@@ -182,6 +186,7 @@ module riscv_decoder
     bmask_a_mux_o               = BMASK_A_ZERO;
     bmask_b_mux_o               = BMASK_B_ZERO;
 
+    is_dift_i                   = 1'b0;
 
     unique case (instr_rdata_i[6:0])
 
@@ -269,44 +274,63 @@ module riscv_decoder
 
       OPCODE_STORE,
       OPCODE_STORE_POST: begin
-        data_req       = 1'b1;
-        data_we_o      = 1'b1;
-        rega_used_o    = 1'b1;
-        regb_used_o    = 1'b1;
-        alu_operator_o = ALU_ADD;
+        // if(instr_rdata_i[14:12] != 3'b111) begin // ¬ p.spsw
+          data_req       = 1'b1;
+          data_we_o      = 1'b1;
+          rega_used_o    = 1'b1;
+          regb_used_o    = 1'b1;
+          alu_operator_o = ALU_ADD;
+
+          // pass write data through ALU operand c
+          alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;
+
+          // post-increment setup
+          if (instr_rdata_i[6:0] == OPCODE_STORE_POST) begin
+            prepost_useincr_o       = 1'b0;
+            regfile_alu_waddr_sel_o = 1'b0;
+            regfile_alu_we          = 1'b1;
+          end
 
-        // pass write data through ALU operand c
-        alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;
+          if (instr_rdata_i[14] == 1'b0) begin
+            // offset from immediate
+            imm_b_mux_sel_o     = IMMB_S;
+            alu_op_b_mux_sel_o  = OP_B_IMM;
+          end else begin
+            // offset from register
+            regc_used_o        = 1'b1;
+            alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
+            regc_mux_o         = REGC_RD;
+          end
 
-        // post-increment setup
-        if (instr_rdata_i[6:0] == OPCODE_STORE_POST) begin
-          prepost_useincr_o       = 1'b0;
-          regfile_alu_waddr_sel_o = 1'b0;
-          regfile_alu_we          = 1'b1;
-        end
+          // store size
+          unique case (instr_rdata_i[13:12])
+            2'b00: data_type_o = 2'b10; // SB
+            2'b01: data_type_o = 2'b01; // SH
+            2'b10: data_type_o = 2'b00; // SW
+            default: begin
+              data_req       = 1'b0;
+              data_we_o      = 1'b0;
+              illegal_insn_o = 1'b1;
+            end
+          endcase
+        // end else begin
+          // p.spsw
 
-        if (instr_rdata_i[14] == 1'b0) begin
-          // offset from immediate
-          imm_b_mux_sel_o     = IMMB_S;
-          alu_op_b_mux_sel_o  = OP_B_IMM;
-        end else begin
-          // offset from register
-          regc_used_o        = 1'b1;
-          alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
-          regc_mux_o         = REGC_RD;
-        end
+          // data_req       = 1'b1;
+          // rega_used_o    = 1'b1;
+          // regb_used_o    = 1'b1;
+          // alu_operator_o = ALU_ADD;
 
-        // store size
-        unique case (instr_rdata_i[13:12])
-          2'b00: data_type_o = 2'b10; // SB
-          2'b01: data_type_o = 2'b01; // SH
-          2'b10: data_type_o = 2'b00; // SW
-          default: begin
-            data_req       = 1'b0;
-            data_we_o      = 1'b0;
-            illegal_insn_o = 1'b1;
-          end
-        endcase
+          // // pass write data through ALU operand c
+          // alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;
+
+          // // offset from immediate
+          // imm_b_mux_sel_o     = IMMB_S;
+          // alu_op_b_mux_sel_o  = OP_B_IMM;
+
+          // // store size
+          // data_type_o = 2'b00; // SW
+        // end
       end
 
       OPCODE_LOAD,
@@ -432,175 +456,178 @@ module riscv_decoder
       end
 
       OPCODE_OP: begin  // Register-Register ALU operation
-        regfile_alu_we = 1'b1;
-        rega_used_o    = 1'b1;
-
-        if (instr_rdata_i[31]) begin
-          // bit-manipulation instructions
-          alu_op_b_mux_sel_o  = OP_B_IMM;
-          bmask_needed_o      = 1'b1;
-          bmask_a_mux_o       = BMASK_A_S3;
-          bmask_b_mux_o       = BMASK_B_S2;
-
-          unique case (instr_rdata_i[14:12])
-            3'b000: begin
-              alu_operator_o  = ALU_BEXT;
-              imm_b_mux_sel_o = IMMB_S2;
-              bmask_b_mux_o   = BMASK_B_ZERO;
-            end
-            3'b001: begin
-              alu_operator_o  = ALU_BEXTU;
-              imm_b_mux_sel_o = IMMB_S2;
-              bmask_b_mux_o   = BMASK_B_ZERO;
-            end
-
-            3'b010: begin
-              alu_operator_o      = ALU_BINS;
-              imm_b_mux_sel_o     = IMMB_S2;
-              regc_used_o         = 1'b1;
-              regc_mux_o          = REGC_RD;
-            end
-
-            3'b011: begin alu_operator_o = ALU_BCLR; end
-            3'b100: begin alu_operator_o = ALU_BSET; end
-
-            default: illegal_insn_o = 1'b1;
-          endcase
-        end
-        else
-        begin // non bit-manipulation instructions
-
-          if (~instr_rdata_i[28])
-            regb_used_o = 1'b1;
-
-          unique case ({instr_rdata_i[30:25], instr_rdata_i[14:12]})
-            // RV32I ALU operations
-            {6'b00_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add
-            {6'b10_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub
-            {6'b00_0000, 3'b010}: alu_operator_o = ALU_SLTS;  // Set Lower Than
-            {6'b00_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned
-            {6'b00_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor
-            {6'b00_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or
-            {6'b00_0000, 3'b111}: alu_operator_o = ALU_AND;   // And
-            {6'b00_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical
-            {6'b00_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical
-            {6'b10_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic
-
-            // supported RV32M instructions
-            {6'b00_0001, 3'b000}: begin // mul
-              mult_int_en_o   = 1'b1;
-              mult_operator_o = MUL_MAC32;
-              regc_mux_o      = REGC_ZERO;
-            end
-            {6'b00_0001, 3'b001}: begin // mulh
-              regc_used_o        = 1'b1;
-              regc_mux_o         = REGC_ZERO;
-              mult_signed_mode_o = 2'b11;
-              mult_int_en_o      = 1'b1;
-              mult_operator_o    = MUL_H;
-            end
-            {6'b00_0001, 3'b010}: begin // mulhsu
-              regc_used_o        = 1'b1;
-              regc_mux_o         = REGC_ZERO;
-              mult_signed_mode_o = 2'b01;
-              mult_int_en_o      = 1'b1;
-              mult_operator_o    = MUL_H;
-            end
-            {6'b00_0001, 3'b011}: begin // mulhu
-              regc_used_o        = 1'b1;
-              regc_mux_o         = REGC_ZERO;
-              mult_signed_mode_o = 2'b00;
-              mult_int_en_o      = 1'b1;
-              mult_operator_o    = MUL_H;
-            end
-            {6'b00_0001, 3'b100}: begin // div
-              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;
-              alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
-              regc_mux_o         = REGC_S1;
-              regc_used_o        = 1'b1;
-              regb_used_o        = 1'b1;
-              rega_used_o        = 1'b0;
-              alu_operator_o     = ALU_DIV;
-            end
-            {6'b00_0001, 3'b101}: begin // divu
-              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;
-              alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
-              regc_mux_o         = REGC_S1;
-              regc_used_o        = 1'b1;
-              regb_used_o        = 1'b1;
-              rega_used_o        = 1'b0;
-              alu_operator_o = ALU_DIVU;
-            end
-            {6'b00_0001, 3'b110}: begin // rem
-              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;
-              alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
-              regc_mux_o         = REGC_S1;
-              regc_used_o        = 1'b1;
-              regb_used_o        = 1'b1;
-              rega_used_o        = 1'b0;
-              alu_operator_o = ALU_REM;
-            end
-            {6'b00_0001, 3'b111}: begin // remu
-              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;
-              alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
-              regc_mux_o         = REGC_S1;
-              regc_used_o        = 1'b1;
-              regb_used_o        = 1'b1;
-              rega_used_o        = 1'b0;
-              alu_operator_o = ALU_REMU;
-            end
-
-            // PULP specific instructions
-            {6'b10_0001, 3'b000}: begin // p.mac
-              regc_used_o     = 1'b1;
-              regc_mux_o      = REGC_RD;
-              mult_int_en_o   = 1'b1;
-              mult_operator_o = MUL_MAC32;
-            end
-            {6'b10_0001, 3'b001}: begin // p.msu
-              regc_used_o     = 1'b1;
-              regc_mux_o      = REGC_RD;
-              mult_int_en_o   = 1'b1;
-              mult_operator_o = MUL_MSU32;
-            end
+        // Avec cette implémentation, p.set est l'équivalent d'un nop
+        if(instr_rdata_i[31:25] != 7'b1011010) begin // ¬ p.set
+          regfile_alu_we = 1'b1;
+          rega_used_o    = 1'b1;
 
-            {6'b00_0010, 3'b010}: alu_operator_o = ALU_SLETS; // Set Lower Equal Than
-            {6'b00_0010, 3'b011}: alu_operator_o = ALU_SLETU; // Set Lower Equal Than Unsigned
-            {6'b00_0010, 3'b100}: alu_operator_o = ALU_MIN;   // Min
-            {6'b00_0010, 3'b101}: alu_operator_o = ALU_MINU;  // Min Unsigned
-            {6'b00_0010, 3'b110}: alu_operator_o = ALU_MAX;   // Max
-            {6'b00_0010, 3'b111}: alu_operator_o = ALU_MAXU;  // Max Unsigned
-
-            {6'b00_0100, 3'b101}: alu_operator_o = ALU_ROR;   // Rotate Right
-
-            // PULP specific instructions using only one source register
-            {6'b00_1000, 3'b000}: alu_operator_o = ALU_FF1;   // Find First 1
-            {6'b00_1000, 3'b001}: alu_operator_o = ALU_FL1;   // Find Last 1
-            {6'b00_1000, 3'b010}: alu_operator_o = ALU_CLB;   // Count Leading Bits
-            {6'b00_1000, 3'b011}: alu_operator_o = ALU_CNT;   // Count set bits (popcount)
-            {6'b00_1000, 3'b100}: begin alu_operator_o = ALU_EXTS; alu_vec_mode_o = VEC_MODE16; end // Sign-extend Half-word
-            {6'b00_1000, 3'b101}: begin alu_operator_o = ALU_EXT;  alu_vec_mode_o = VEC_MODE16; end // Zero-extend Half-word
-            {6'b00_1000, 3'b110}: begin alu_operator_o = ALU_EXTS; alu_vec_mode_o = VEC_MODE8;  end // Sign-extend Byte
-            {6'b00_1000, 3'b111}: begin alu_operator_o = ALU_EXT;  alu_vec_mode_o = VEC_MODE8;  end // Zero-extend Byte
-
-            {6'b00_0010, 3'b000}: alu_operator_o = ALU_ABS;   // p.abs
-
-            {6'b00_1010, 3'b001}: begin // p.clip
-              alu_operator_o     = ALU_CLIP;
-              alu_op_b_mux_sel_o = OP_A_IMM;
-              imm_b_mux_sel_o    = IMMB_CLIP;
-            end
-
-            {6'b00_1010, 3'b010}: begin // p.clipu
-              alu_operator_o     = ALU_CLIPU;
-              alu_op_b_mux_sel_o = OP_A_IMM;
-              imm_b_mux_sel_o    = IMMB_CLIP;
-            end
-
-            default: begin
-              illegal_insn_o = 1'b1;
-            end
-          endcase
+          if (instr_rdata_i[31]) begin
+            // bit-manipulation instructions
+            alu_op_b_mux_sel_o  = OP_B_IMM;
+            bmask_needed_o      = 1'b1;
+            bmask_a_mux_o       = BMASK_A_S3;
+            bmask_b_mux_o       = BMASK_B_S2;
+
+            unique case (instr_rdata_i[14:12])
+              3'b000: begin
+                alu_operator_o  = ALU_BEXT;
+                imm_b_mux_sel_o = IMMB_S2;
+                bmask_b_mux_o   = BMASK_B_ZERO;
+              end
+              3'b001: begin
+                alu_operator_o  = ALU_BEXTU;
+                imm_b_mux_sel_o = IMMB_S2;
+                bmask_b_mux_o   = BMASK_B_ZERO;
+              end
+
+              3'b010: begin
+                alu_operator_o      = ALU_BINS;
+                imm_b_mux_sel_o     = IMMB_S2;
+                regc_used_o         = 1'b1;
+                regc_mux_o          = REGC_RD;
+              end
+
+              3'b011: begin alu_operator_o = ALU_BCLR; end
+              3'b100: begin alu_operator_o = ALU_BSET; end
+
+              default: illegal_insn_o = 1'b1;
+            endcase
+          end
+          else
+          begin // non bit-manipulation instructions
+
+            if (~instr_rdata_i[28])
+              regb_used_o = 1'b1;
+
+            unique case ({instr_rdata_i[30:25], instr_rdata_i[14:12]})
+              // RV32I ALU operations
+              {6'b00_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add
+              {6'b10_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub
+              {6'b00_0000, 3'b010}: alu_operator_o = ALU_SLTS;  // Set Lower Than
+              {6'b00_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned
+              {6'b00_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor
+              {6'b00_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or
+              {6'b00_0000, 3'b111}: alu_operator_o = ALU_AND;   // And
+              {6'b00_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical
+              {6'b00_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical
+              {6'b10_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic
+
+              // supported RV32M instructions
+              {6'b00_0001, 3'b000}: begin // mul
+                mult_int_en_o   = 1'b1;
+                mult_operator_o = MUL_MAC32;
+                regc_mux_o      = REGC_ZERO;
+              end
+              {6'b00_0001, 3'b001}: begin // mulh
+                regc_used_o        = 1'b1;
+                regc_mux_o         = REGC_ZERO;
+                mult_signed_mode_o = 2'b11;
+                mult_int_en_o      = 1'b1;
+                mult_operator_o    = MUL_H;
+              end
+              {6'b00_0001, 3'b010}: begin // mulhsu
+                regc_used_o        = 1'b1;
+                regc_mux_o         = REGC_ZERO;
+                mult_signed_mode_o = 2'b01;
+                mult_int_en_o      = 1'b1;
+                mult_operator_o    = MUL_H;
+              end
+              {6'b00_0001, 3'b011}: begin // mulhu
+                regc_used_o        = 1'b1;
+                regc_mux_o         = REGC_ZERO;
+                mult_signed_mode_o = 2'b00;
+                mult_int_en_o      = 1'b1;
+                mult_operator_o    = MUL_H;
+              end
+              {6'b00_0001, 3'b100}: begin // div
+                alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;
+                alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
+                regc_mux_o         = REGC_S1;
+                regc_used_o        = 1'b1;
+                regb_used_o        = 1'b1;
+                rega_used_o        = 1'b0;
+                alu_operator_o     = ALU_DIV;
+              end
+              {6'b00_0001, 3'b101}: begin // divu
+                alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;
+                alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
+                regc_mux_o         = REGC_S1;
+                regc_used_o        = 1'b1;
+                regb_used_o        = 1'b1;
+                rega_used_o        = 1'b0;
+                alu_operator_o = ALU_DIVU;
+              end
+              {6'b00_0001, 3'b110}: begin // rem
+                alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;
+                alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
+                regc_mux_o         = REGC_S1;
+                regc_used_o        = 1'b1;
+                regb_used_o        = 1'b1;
+                rega_used_o        = 1'b0;
+                alu_operator_o = ALU_REM;
+              end
+              {6'b00_0001, 3'b111}: begin // remu
+                alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;
+                alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
+                regc_mux_o         = REGC_S1;
+                regc_used_o        = 1'b1;
+                regb_used_o        = 1'b1;
+                rega_used_o        = 1'b0;
+                alu_operator_o = ALU_REMU;
+              end
+
+              // PULP specific instructions
+              {6'b10_0001, 3'b000}: begin // p.mac
+                regc_used_o     = 1'b1;
+                regc_mux_o      = REGC_RD;
+                mult_int_en_o   = 1'b1;
+                mult_operator_o = MUL_MAC32;
+              end
+              {6'b10_0001, 3'b001}: begin // p.msu
+                regc_used_o     = 1'b1;
+                regc_mux_o      = REGC_RD;
+                mult_int_en_o   = 1'b1;
+                mult_operator_o = MUL_MSU32;
+              end
+
+              {6'b00_0010, 3'b010}: alu_operator_o = ALU_SLETS; // Set Lower Equal Than
+              {6'b00_0010, 3'b011}: alu_operator_o = ALU_SLETU; // Set Lower Equal Than Unsigned
+              {6'b00_0010, 3'b100}: alu_operator_o = ALU_MIN;   // Min
+              {6'b00_0010, 3'b101}: alu_operator_o = ALU_MINU;  // Min Unsigned
+              {6'b00_0010, 3'b110}: alu_operator_o = ALU_MAX;   // Max
+              {6'b00_0010, 3'b111}: alu_operator_o = ALU_MAXU;  // Max Unsigned
+
+              {6'b00_0100, 3'b101}: alu_operator_o = ALU_ROR;   // Rotate Right
+
+              // PULP specific instructions using only one source register
+              {6'b00_1000, 3'b000}: alu_operator_o = ALU_FF1;   // Find First 1
+              {6'b00_1000, 3'b001}: alu_operator_o = ALU_FL1;   // Find Last 1
+              {6'b00_1000, 3'b010}: alu_operator_o = ALU_CLB;   // Count Leading Bits
+              {6'b00_1000, 3'b011}: alu_operator_o = ALU_CNT;   // Count set bits (popcount)
+              {6'b00_1000, 3'b100}: begin alu_operator_o = ALU_EXTS; alu_vec_mode_o = VEC_MODE16; end // Sign-extend Half-word
+              {6'b00_1000, 3'b101}: begin alu_operator_o = ALU_EXT;  alu_vec_mode_o = VEC_MODE16; end // Zero-extend Half-word
+              {6'b00_1000, 3'b110}: begin alu_operator_o = ALU_EXTS; alu_vec_mode_o = VEC_MODE8;  end // Sign-extend Byte
+              {6'b00_1000, 3'b111}: begin alu_operator_o = ALU_EXT;  alu_vec_mode_o = VEC_MODE8;  end // Zero-extend Byte
+
+              {6'b00_0010, 3'b000}: alu_operator_o = ALU_ABS;   // p.abs
+
+              {6'b00_1010, 3'b001}: begin // p.clip
+                alu_operator_o     = ALU_CLIP;
+                alu_op_b_mux_sel_o = OP_A_IMM;
+                imm_b_mux_sel_o    = IMMB_CLIP;
+              end
+
+              {6'b00_1010, 3'b010}: begin // p.clipu
+                alu_operator_o     = ALU_CLIPU;
+                alu_op_b_mux_sel_o = OP_A_IMM;
+                imm_b_mux_sel_o    = IMMB_CLIP;
+              end
+
+              default: begin
+                illegal_insn_o = 1'b1;
+              end
+            endcase
+          end
         end
       end
 
@@ -818,7 +845,6 @@ module riscv_decoder
         endcase
       end
 
-
       ////////////////////////////////////////////////
       //  ____  ____  _____ ____ ___    _    _      //
       // / ___||  _ \| ____/ ___|_ _|  / \  | |     //
@@ -951,6 +977,47 @@ module riscv_decoder
         endcase
       end
 
+      /////////////////////////////
+      //   ____ ___ _____ _____  //
+      //  |  _ \_ _|  ___|_   _| //
+      //  | | | | || |_    | |   //
+      //  | |_| | ||  _|   | |   //
+      //  |____/___|_|     |_|   //
+      //                         //
+      /////////////////////////////
+
+      `ifdef DIFT
+      // p.spsw / p.spsh / p.spsb / p.hmem
+      OPCODE_DIFT_STORE: begin
+
+        is_dift_i                   = 1'b1;
+                
+        // p.spsw ra, offset(rb)
+        data_req       = 1'b1;    // start transaction to data memory
+        data_we_o      = 1'b0;    
+
+        rega_used_o    = 1'b1;    // rs1 is used by current instruction
+        regb_used_o    = 1'b1;    // rs2 is used by current instruction
+        alu_operator_o = ALU_ADD; // ALU operation selection
+
+        // pass write data through ALU operand c
+        alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;
+
+        // offset from immediate
+        imm_b_mux_sel_o     = IMMB_S;
+        alu_op_b_mux_sel_o  = OP_B_IMM;
+
+        // store size
+        unique case (instr_rdata_i[13:12])
+          2'b00: data_type_o = 2'b00; // SW (p.spsw)
+          2'b01: data_type_o = 2'b01; // SH (p.spsh)
+          2'b10: data_type_o = 2'b10; // SB (p.spsb)
+          2'b11: data_type_o = 2'b00; // SW (p.hmem)
+        endcase
+
+      end
+      `endif
+
       default: begin
         illegal_insn_o = 1'b1;
       end
@@ -991,8 +1058,8 @@ module riscv_decoder
   assign regfile_alu_we_o  = (deassert_we_i) ? 1'b0          : regfile_alu_we;
   assign data_req_o        = (deassert_we_i) ? 1'b0          : data_req;
   assign hwloop_we_o       = (deassert_we_i) ? 3'b0          : hwloop_we;
-  assign csr_op_o          = (deassert_we_i) ? CSR_OP_NONE  : csr_op;
-  assign jump_in_id_o      = (deassert_we_i) ? BRANCH_NONE  : jump_in_id;
+  assign csr_op_o          = (deassert_we_i) ? CSR_OP_NONE   : csr_op;
+  assign jump_in_id_o      = (deassert_we_i) ? BRANCH_NONE   : jump_in_id;
   assign ebrk_insn_o       = (deassert_we_i) ? 1'b0          : ebrk_insn;
   assign eret_insn_o       = (deassert_we_i) ? 1'b0          : eret_insn;  // TODO: do not deassert?
   assign pipe_flush_o      = (deassert_we_i) ? 1'b0          : pipe_flush; // TODO: do not deassert?
diff --git a/ex_stage.sv b/ex_stage.sv
index 06daf25..99145e6 100644
--- a/ex_stage.sv
+++ b/ex_stage.sv
@@ -16,7 +16,7 @@
 //                 Sven Stucki - svstucki@student.ethz.ch                     //
 //                 Andreas Traber - atraber@iis.ee.ethz.ch                    //
 //                                                                            //
-// Design Name:    Excecute stage                                             //
+// Design Name:    Execute stage                                              //
 // Project Name:   RI5CY                                                      //
 // Language:       SystemVerilog                                              //
 //                                                                            //
@@ -26,200 +26,344 @@
 //                                                                            //
 ////////////////////////////////////////////////////////////////////////////////
 
-import riscv_defines::*;
+`include "riscv_config.sv"
 
+import riscv_defines::*;
 
 module riscv_ex_stage
 (
-  input  logic        clk,
-  input  logic        rst_n,
-
-  // ALU signals from ID stage
-  input  logic [ALU_OP_WIDTH-1:0] alu_operator_i,
-  input  logic [31:0] alu_operand_a_i,
-  input  logic [31:0] alu_operand_b_i,
-  input  logic [31:0] alu_operand_c_i,
-  input  logic [ 4:0] bmask_a_i,
-  input  logic [ 4:0] bmask_b_i,
-  input  logic [ 1:0] imm_vec_ext_i,
-  input  logic [ 1:0] alu_vec_mode_i,
-
-  // Multiplier signals
-  input  logic [ 2:0] mult_operator_i,
-  input  logic [31:0] mult_operand_a_i,
-  input  logic [31:0] mult_operand_b_i,
-  input  logic [31:0] mult_operand_c_i,
-  input  logic        mult_en_i,
-  input  logic        mult_sel_subword_i,
-  input  logic [ 1:0] mult_signed_mode_i,
-  input  logic [ 4:0] mult_imm_i,
-
-  input  logic [31:0] mult_dot_op_a_i,
-  input  logic [31:0] mult_dot_op_b_i,
-  input  logic [31:0] mult_dot_op_c_i,
-  input  logic [ 1:0] mult_dot_signed_i,
-
-  output logic        mult_multicycle_o,
-
-  // input from ID stage
-  input  logic        branch_in_ex_i,
-  input  logic [4:0]  regfile_alu_waddr_i,
-  input  logic        regfile_alu_we_i,
-
-  // directly passed through to WB stage, not used in EX
-  input  logic        regfile_we_i,
-  input  logic [4:0]  regfile_waddr_i,
-
-  // CSR access
-  input  logic        csr_access_i,
-  input  logic [31:0] csr_rdata_i,
-
-  // Output of EX stage pipeline
-  output logic [4:0]  regfile_waddr_wb_o,
-  output logic        regfile_we_wb_o,
-
-  // Forwarding ports : to ID stage
-  output logic  [4:0] regfile_alu_waddr_fw_o,
-  output logic        regfile_alu_we_fw_o,
-  output logic [31:0] regfile_alu_wdata_fw_o,    // forward to RF and ID/EX pipe, ALU & MUL
-
-  // To IF: Jump and branch target and decision
-  output logic [31:0] jump_target_o,
-  output logic        branch_decision_o,
-
-  // Stall Control
-  input  logic        lsu_ready_ex_i, // EX part of LSU is done
-
-  output logic        ex_ready_o, // EX stage ready for new data
-  output logic        ex_valid_o, // EX stage gets new data
-  input  logic        wb_ready_i  // WB stage ready for new data
+	input  logic        clk,
+	input  logic        rst_n,
+
+	// ALU signals from ID stage
+	input  logic [ALU_OP_WIDTH-1:0] alu_operator_i,
+	input  logic [31:0] alu_operand_a_i,
+	input  logic [31:0] alu_operand_b_i,
+	input  logic [31:0] alu_operand_c_i,
+	input  logic [ 4:0] bmask_a_i,
+	input  logic [ 4:0] bmask_b_i,
+	input  logic [ 1:0] imm_vec_ext_i,
+	input  logic [ 1:0] alu_vec_mode_i,
+
+	// Multiplier signals
+	input  logic [ 2:0] mult_operator_i,
+	input  logic [31:0] mult_operand_a_i,
+	input  logic [31:0] mult_operand_b_i,
+	input  logic [31:0] mult_operand_c_i,
+	input  logic        mult_en_i,
+	input  logic        mult_sel_subword_i,
+	input  logic [ 1:0] mult_signed_mode_i,
+	input  logic [ 4:0] mult_imm_i,
+
+	input  logic [31:0] mult_dot_op_a_i,
+	input  logic [31:0] mult_dot_op_b_i,
+	input  logic [31:0] mult_dot_op_c_i,
+	input  logic [ 1:0] mult_dot_signed_i,
+
+	output logic        mult_multicycle_o,
+
+	// Input from ID stage
+	input  logic        branch_in_ex_i,
+	input  logic [4:0]  regfile_alu_waddr_i,
+	input  logic        regfile_alu_we_i,
+
+	// Directly passed through to WB stage, not used in EX
+	input  logic        regfile_we_i,
+	input  logic [4:0]  regfile_waddr_i,
+
+	// CSR access
+	input  logic        csr_access_i,
+	input  logic [31:0] csr_rdata_i,
+
+	// Output of EX stage pipeline
+	output logic [4:0]  regfile_waddr_wb_o,
+	output logic        regfile_we_wb_o,
+
+	// Forwarding ports : to ID stage
+	output logic  [4:0] regfile_alu_waddr_fw_o,
+	output logic        regfile_alu_we_fw_o,
+	output logic [31:0] regfile_alu_wdata_fw_o,    // forward to RF and ID/EX pipe, ALU & MUL
+
+	// To IF: Jump and branch target and decision
+	output logic [31:0] jump_target_o,
+	output logic        branch_decision_o,
+
+	// Stall Control
+	input  logic        lsu_ready_ex_i, // EX part of LSU is done
+
+	output logic        ex_ready_o, // EX stage ready for new data
+	output logic        ex_valid_o, // EX stage gets new data
+	input  logic        wb_ready_i  // WB stage ready for new data
+
+`ifdef DIFT // Ajout de tous les tags des registres en entrée
+	,
+	input  logic [ALU_MODE_WIDTH-1:0] alu_operator_i_mode,
+	input  logic        alu_operand_a_i_tag,
+	input  logic        alu_operand_b_i_tag,
+	input  logic        alu_operand_c_i_tag,
+	input  logic        data_we_ex_i,
+	input  logic        check_s1_i_tag,
+	input  logic        check_s2_i_tag,
+	input  logic        check_d_i_tag,
+	input  logic        register_set_i_tag,
+	input  logic        memory_set_i_tag,
+	input  logic        is_store_post_i_tag,
+`ifdef DIFT_H
+	input  logic [6:0]  regfile_alu_waddr_i_tag, // Adresse du registre de destination
+`else
+	input  logic [4:0]  regfile_alu_waddr_i_tag,
+`endif
+	input  logic        store_dest_addr_i_tag,
+	input  logic        store_source_i_tag,
+	input  logic        use_store_ops_i,
+	output logic        regfile_alu_wdata_fw_o_tag,
+	output logic        regfile_alu_we_fw_o_tag,
+`ifdef DIFT_H
+	output logic [6:0]  regfile_alu_waddr_fw_o_tag,
+`else
+	input  logic [4:0]  regfile_alu_waddr_fw_o_tag,
+`endif
+	output logic        jump_target_o_tag,
+	output logic        pc_enable_o_tag,
+	output logic        data_wdata_ex_o_tag,
+	output logic        data_we_ex_o_tag,
+	output logic        rs1_o_tag,
+	output logic        exception_o_tag
+`endif
 );
 
-
-  logic [31:0] alu_result;
-  logic [31:0] alu_csr_result;
-  logic [31:0] mult_result;
-  logic        alu_cmp_result;
-
-  logic        alu_ready;
-  logic        mult_ready;
-
-
-  // EX stage result mux (ALU, MAC unit, CSR)
-  assign alu_csr_result         = csr_access_i ? csr_rdata_i : alu_result;
-
-  assign regfile_alu_wdata_fw_o = mult_en_i ? mult_result : alu_csr_result;
-
-
-  assign regfile_alu_we_fw_o    = regfile_alu_we_i;
-  assign regfile_alu_waddr_fw_o = regfile_alu_waddr_i;
-
-
-  // branch handling
-  assign branch_decision_o = alu_cmp_result;
-  assign jump_target_o     = alu_operand_c_i;
-
-
-  ////////////////////////////
-  //     _    _    _   _    //
-  //    / \  | |  | | | |   //
-  //   / _ \ | |  | | | |   //
-  //  / ___ \| |__| |_| |   //
-  // /_/   \_\_____\___/    //
-  //                        //
-  ////////////////////////////
-
-  riscv_alu alu_i
-  (
-    .clk                 ( clk             ),
-    .rst_n               ( rst_n           ),
-
-    .operator_i          ( alu_operator_i  ),
-    .operand_a_i         ( alu_operand_a_i ),
-    .operand_b_i         ( alu_operand_b_i ),
-    .operand_c_i         ( alu_operand_c_i ),
-
-    .vector_mode_i       ( alu_vec_mode_i  ),
-    .bmask_a_i           ( bmask_a_i       ),
-    .bmask_b_i           ( bmask_b_i       ),
-    .imm_vec_ext_i       ( imm_vec_ext_i   ),
-
-    .result_o            ( alu_result      ),
-    .comparison_result_o ( alu_cmp_result  ),
-
-    .ready_o             ( alu_ready       ),
-    .ex_ready_i          ( ex_ready_o      )
-  );
-
-
-  ////////////////////////////////////////////////////////////////
-  //  __  __ _   _ _   _____ ___ ____  _     ___ _____ ____     //
-  // |  \/  | | | | | |_   _|_ _|  _ \| |   |_ _| ____|  _ \    //
-  // | |\/| | | | | |   | |  | || |_) | |    | ||  _| | |_) |   //
-  // | |  | | |_| | |___| |  | ||  __/| |___ | || |___|  _ <    //
-  // |_|  |_|\___/|_____|_| |___|_|   |_____|___|_____|_| \_\   //
-  //                                                            //
-  ////////////////////////////////////////////////////////////////
-
-  riscv_mult mult_i
-  (
-    .clk             ( clk                  ),
-    .rst_n           ( rst_n                ),
-
-    .enable_i        ( mult_en_i            ),
-    .operator_i      ( mult_operator_i      ),
-
-    .short_subword_i ( mult_sel_subword_i   ),
-    .short_signed_i  ( mult_signed_mode_i   ),
-
-    .op_a_i          ( mult_operand_a_i     ),
-    .op_b_i          ( mult_operand_b_i     ),
-    .op_c_i          ( mult_operand_c_i     ),
-    .imm_i           ( mult_imm_i           ),
-
-    .dot_op_a_i      ( mult_dot_op_a_i      ),
-    .dot_op_b_i      ( mult_dot_op_b_i      ),
-    .dot_op_c_i      ( mult_dot_op_c_i      ),
-    .dot_signed_i    ( mult_dot_signed_i    ),
-
-    .result_o        ( mult_result          ),
-
-    .multicycle_o    ( mult_multicycle_o    ),
-    .ready_o         ( mult_ready           ),
-    .ex_ready_i      ( ex_ready_o           )
-  );
-
-
-  ///////////////////////////////////////
-  // EX/WB Pipeline Register           //
-  ///////////////////////////////////////
-  always_ff @(posedge clk, negedge rst_n)
-  begin : EX_WB_Pipeline_Register
-    if (~rst_n)
-    begin
-      regfile_waddr_wb_o   <= '0;
-      regfile_we_wb_o      <= 1'b0;
-    end
-    else
-    begin
-      if (ex_valid_o) // wb_ready_i is implied
-      begin
-        regfile_we_wb_o    <= regfile_we_i;
-        if (regfile_we_i) begin
-          regfile_waddr_wb_o <= regfile_waddr_i;
-        end
-      end else if (wb_ready_i) begin
-        // we are ready for a new instruction, but there is none available,
-        // so we just flush the current one out of the pipe
-        regfile_we_wb_o    <= 1'b0;
-      end
-    end
-  end
-
-  // As valid always goes to the right and ready to the left, and we are able
-  // to finish branches without going to the WB stage, ex_valid does not
-  // depend on ex_ready.
-  assign ex_ready_o = (alu_ready & mult_ready & lsu_ready_ex_i & wb_ready_i) | branch_in_ex_i;
-  assign ex_valid_o = (alu_ready & mult_ready & lsu_ready_ex_i & wb_ready_i);
+	logic [31:0] alu_result;
+	logic [31:0] alu_csr_result;
+	logic [31:0] mult_result;
+	logic        alu_cmp_result;
+
+	logic        alu_ready;
+	logic        mult_ready;
+
+`ifdef DIFT 
+	logic        alu_result_tag;
+	logic        rf_enable_tag;
+	logic        pc_enable_tag;
+	logic        check_a;
+	logic        check_b;
+`endif
+
+	// EX stage result mux (ALU, MAC unit, CSR)
+	assign alu_csr_result         = csr_access_i ? csr_rdata_i : alu_result;
+
+	assign regfile_alu_wdata_fw_o = mult_en_i ? mult_result : alu_csr_result;
+
+	assign regfile_alu_we_fw_o    = regfile_alu_we_i;
+	assign regfile_alu_waddr_fw_o = regfile_alu_waddr_i;
+
+	// branch handling
+	assign branch_decision_o      = alu_cmp_result;
+	assign jump_target_o          = alu_operand_c_i;
+
+`ifdef DIFT   //Mise à jour des tags
+	// Register instruction except Load
+	always_comb begin
+		if (register_set_i_tag) begin
+			regfile_alu_wdata_fw_o_tag = 1'b1;
+			regfile_alu_we_fw_o_tag    = 1'b1;
+		end else begin
+			regfile_alu_wdata_fw_o_tag = alu_result_tag;
+			regfile_alu_we_fw_o_tag    = rf_enable_tag & regfile_alu_we_i & ~(is_store_post_i_tag);
+		end
+	end
+	assign regfile_alu_waddr_fw_o_tag = regfile_alu_waddr_i_tag;
+
+	// Store
+	always_comb begin
+		if (memory_set_i_tag) begin
+			data_wdata_ex_o_tag        = 1'b1;  // M[RS1+offset]: destination tag
+			data_we_ex_o_tag           = 1'b1;
+		end else begin
+			data_wdata_ex_o_tag        = alu_result_tag;  // M[RS1+offset]: destination tag
+			data_we_ex_o_tag           = data_we_ex_i & rf_enable_tag;
+		end
+	end
+
+	// Branch
+	// if (branch is not taken)
+	//   old PC tag is not updated;
+	// else
+	//   if (old PC tag is equal to 1)
+	//     new PC tag is equal to 1;
+	//   else
+	//     new PC tag is the result of the policy applied on the source operands;
+	always_comb
+	begin
+		if (~alu_cmp_result) begin
+			pc_enable_o_tag = 1'b0;
+		end else begin
+			if (alu_operand_c_i_tag) begin
+				pc_enable_o_tag   = 1'b1;
+				jump_target_o_tag = alu_operand_c_i_tag;
+			end else begin
+				pc_enable_o_tag   = pc_enable_tag;
+				jump_target_o_tag = alu_result_tag;
+			end
+		end
+	end
+`endif
+
+	////////////////////////////
+	//     _    _    _   _    //
+	//    / \  | |  | | | |   //
+	//   / _ \ | |  | | | |   //
+	//  / ___ \| |__| |_| |   //
+	// /_/   \_\_____\___/    //
+	//                        //
+	////////////////////////////
+
+	riscv_alu alu_i
+	(
+		.clk                 ( clk             ),
+		.rst_n               ( rst_n           ),
+
+		.operator_i          ( alu_operator_i  ),
+		.operand_a_i         ( alu_operand_a_i ),
+		.operand_b_i         ( alu_operand_b_i ),
+		.operand_c_i         ( alu_operand_c_i ),
+
+		.vector_mode_i       ( alu_vec_mode_i  ),
+		.bmask_a_i           ( bmask_a_i       ),
+		.bmask_b_i           ( bmask_b_i       ),
+		.imm_vec_ext_i       ( imm_vec_ext_i   ),
+
+		.result_o            ( alu_result      ),
+		.comparison_result_o ( alu_cmp_result  ),
+
+		.ready_o             ( alu_ready       ),
+		.ex_ready_i          ( ex_ready_o      )
+	);
+
+	////////////////////////////////////////////////////////
+	//  ____ ___ _____ _____   _     ___   ____ ___ ____  //
+	// |  _ \_ _|  ___|_   _| | |   / _ \ / ___|_ _/ ___| //
+	// | | | | || |_    | |   | |  | | | | |  _ | | |     //
+	// | |_| | ||  _|   | |   | |__| |_| | |_| || | |___  //
+	// |____/___|_|     |_|   |_____\___/ \____|___\____| //
+	//                                                    //
+	////////////////////////////////////////////////////////
+
+`ifdef DIFT // Récupération des infos du TPR prémachées par le décodeur
+	riscv_tag_propagation_logic tag_propagation_logic_i
+	(
+		.operator_i           ( alu_operator_i_mode     ),
+		.operand_a_i          ( alu_operand_a_i_tag     ),
+		.operand_b_i          ( alu_operand_b_i_tag     ),
+		.result_o             ( alu_result_tag          ),
+		.rf_enable_tag        ( rf_enable_tag           ),
+		.pc_enable_tag        ( pc_enable_tag           )
+	);
+`endif
+
+`ifdef DIFT // Récupération des infos du TCR prémachées par le décodeur
+	assign check_a = use_store_ops_i ? store_dest_addr_i_tag : alu_operand_a_i_tag;
+	assign check_b = use_store_ops_i ? store_source_i_tag : alu_operand_b_i_tag;
+
+	riscv_tag_check_logic tag_check_logic_i
+	(
+		.operand_a_i          ( check_a                 ),
+		.operand_b_i          ( check_b                 ),
+		.result_i             ( alu_result_tag          ),
+		.check_s1_i           ( check_s1_i_tag          ),
+		.check_s2_i           ( check_s2_i_tag          ),
+		.check_d_i            ( check_d_i_tag           ),
+		.is_load_i            ( regfile_we_i            ),
+		.exception_o          ( exception_o_tag         )
+	);
+`endif
+
+	////////////////////////////////////////////////////////////////
+	//  __  __ _   _ _   _____ ___ ____  _     ___ _____ ____     //
+	// |  \/  | | | | | |_   _|_ _|  _ \| |   |_ _| ____|  _ \    //
+	// | |\/| | | | | |   | |  | || |_) | |    | ||  _| | |_) |   //
+	// | |  | | |_| | |___| |  | ||  __/| |___ | || |___|  _ <    //
+	// |_|  |_|\___/|_____|_| |___|_|   |_____|___|_____|_| \_\   //
+	//                                                            //
+	////////////////////////////////////////////////////////////////
+
+	riscv_mult mult_i
+	(
+		.clk             ( clk                  ),
+		.rst_n           ( rst_n                ),
+
+		.enable_i        ( mult_en_i            ),
+		.operator_i      ( mult_operator_i      ),
+
+		.short_subword_i ( mult_sel_subword_i   ),
+		.short_signed_i  ( mult_signed_mode_i   ),
+
+		.op_a_i          ( mult_operand_a_i     ),
+		.op_b_i          ( mult_operand_b_i     ),
+		.op_c_i          ( mult_operand_c_i     ),
+		.imm_i           ( mult_imm_i           ),
+
+		.dot_op_a_i      ( mult_dot_op_a_i      ),
+		.dot_op_b_i      ( mult_dot_op_b_i      ),
+		.dot_op_c_i      ( mult_dot_op_c_i      ),
+		.dot_signed_i    ( mult_dot_signed_i    ),
+
+		.result_o        ( mult_result          ),
+
+		.multicycle_o    ( mult_multicycle_o    ),
+		.ready_o         ( mult_ready           ),
+		.ex_ready_i      ( ex_ready_o           )
+	);
+
+	///////////////////////////////////////
+	// EX/WB Pipeline Register           //
+	///////////////////////////////////////
+	always_ff @(posedge clk, negedge rst_n)
+	begin : EX_WB_Pipeline_Register
+		if (~rst_n)
+		begin
+			regfile_waddr_wb_o   <= '0;
+			regfile_we_wb_o      <= 1'b0;
+		end
+		else
+		begin
+			if (ex_valid_o) // wb_ready_i is implied
+			begin
+				regfile_we_wb_o      <= regfile_we_i;
+				if (regfile_we_i) begin
+					regfile_waddr_wb_o <= regfile_waddr_i;
+				end
+			end else if (wb_ready_i) begin
+				// we are ready for a new instruction, but there is none available,
+				// so we just flush the current one out of the pipe
+				regfile_we_wb_o      <= 1'b0;
+			end
+		end
+	end
+
+`ifdef DIFT // Mise à jour du tag dans le cadre du LOAD
+	// Load
+	always_ff @(posedge clk, negedge rst_n)
+	begin
+		if (~rst_n)
+		begin
+			rs1_o_tag            <= 1'b0;
+		end
+		else
+		begin
+			if (ex_valid_o)
+			begin
+				if (regfile_we_i) begin
+					rs1_o_tag        <= alu_operand_a_i_tag;
+				end
+			end
+		end
+	end
+`endif
+
+	// As valid always goes to the right and ready to the left, and we are able
+	// to finish branches without going to the WB stage, ex_valid does not
+	// depend on ex_ready.
+	assign ex_ready_o = (alu_ready & mult_ready & lsu_ready_ex_i & wb_ready_i) | branch_in_ex_i;
+	assign ex_valid_o = (alu_ready & mult_ready & lsu_ready_ex_i & wb_ready_i);
 
 endmodule
diff --git a/id_stage.sv b/id_stage.sv
index 01389e1..8daadd8 100644
--- a/id_stage.sv
+++ b/id_stage.sv
@@ -25,6 +25,7 @@
 //                                                                            //
 ////////////////////////////////////////////////////////////////////////////////
 
+`include "riscv_config.sv"
 
 import riscv_defines::*;
 
@@ -56,7 +57,6 @@ module riscv_id_stage
     input  logic       [31:0] instr_rdata_i,      // comes from pipeline of IF stage
     output logic              instr_req_o,
 
-
     // Jumps and branches
     output logic        branch_in_ex_o,
     input  logic        branch_decision_i,
@@ -107,7 +107,6 @@ module riscv_id_stage
     // ALU
     output logic [ALU_OP_WIDTH-1:0] alu_operator_ex_o,
 
-
     // MUL
     output logic [ 2:0] mult_operator_ex_o,
     output logic [31:0] mult_operand_a_ex_o,
@@ -197,6 +196,42 @@ module riscv_id_stage
     output logic        perf_jump_o,          // we are executing a jump instruction
     output logic        perf_jr_stall_o,      // jump-register-hazard
     output logic        perf_ld_stall_o       // load-use-hazard
+
+// DIFT signals
+`ifdef DIFT
+    ,
+    input  logic        regfile_wdata_wb_i_tag,            // From WB stage
+    input  logic        regfile_alu_wdata_fw_i_tag,        // From tags ALU (EX stage)
+    input  logic        regfile_alu_we_fw_i_tag,           // From tags ALU (EX stage)
+    input  logic [4:0]  regfile_alu_waddr_fw_i_tag,        // From EX
+    input  logic [31:0] tpr_i,                             // From CRS
+    input  logic [31:0] tcr_i,                             // From CRS
+`ifdef DIFT_H
+    input  logic [31:0] thr_i,                             // From CRS
+    input  logic        regfile_wdata_wb_i_htag,            // From WB stage
+`endif
+    input  logic        pc_id_i_tag,                       // From IF
+    input  logic        pc_enable_i_tag,                   // From EX
+    input  logic        rs1_i_tag,                         // From EX
+    input  logic        exception_i_tag,                   // From EX
+    output logic        jump_target_o_tag,                 // To IF
+    output logic        pc_ex_o_tag,                       // To CSR (?)
+    output logic        pc_set_o_tag,                      // To IF
+    output logic [ALU_MODE_WIDTH-1:0] alu_operator_o_mode, // To EX
+    output logic        store_dest_addr_ex_o_tag,          // To EX
+    output logic        store_source_ex_o_tag,             // To EX
+    output logic        use_store_ops_ex_o,                // To EX
+    output logic        alu_operand_a_ex_o_tag,            // To EX
+    output logic        alu_operand_b_ex_o_tag,            // To EX
+    output logic        alu_operand_c_ex_o_tag,            // To EX
+    output logic [4:0]  regfile_alu_waddr_ex_o_tag,        // To EX
+    output logic        check_s1_o_tag,                    // To EX
+    output logic        check_s2_o_tag,                    // To EX
+    output logic        check_d_o_tag,                     // To EX
+    output logic        register_set_o_tag,                // To EX
+    output logic        is_store_post_o_tag,               // To EX
+    output logic        memory_set_o_tag                   // To EX
+`endif
 );
 
   logic [31:0] instr;
@@ -205,6 +240,7 @@ module riscv_id_stage
   logic        deassert_we;
 
   logic        illegal_insn_dec;
+  logic        illegal_insn_dec_dift;
   logic        ebrk_insn;
   logic        eret_insn_dec;
   logic        ecall_insn_dec;
@@ -225,7 +261,6 @@ module riscv_id_stage
 
   logic        halt_id;
 
-
   // Immediate decoding and sign extension
   logic [31:0] imm_i_type;
   logic [31:0] imm_iz_type;
@@ -249,8 +284,6 @@ module riscv_id_stage
 
   logic [31:0] jump_target;       // calculated jump target (-> EX -> IF)
 
-
-
   // Signals running between controller and exception controller
   logic        exc_req, exc_ack;  // handshake
 
@@ -357,6 +390,34 @@ module riscv_id_stage
   logic        reg_d_alu_is_reg_b_id;
   logic        reg_d_alu_is_reg_c_id;
 
+`ifdef DIFT
+  logic        regfile_data_ra_id_tag;
+  logic        regfile_data_rb_id_tag;
+  logic        regfile_data_rc_id_tag;
+  logic        alu_operand_a_tag;
+  logic        alu_operand_b_tag;
+  logic        alu_operand_c_tag;
+  logic        operand_a_fw_id_tag;
+  logic        operand_b_fw_id_tag;
+  logic        operand_c_fw_id_tag;
+  logic        operand_b_tag;
+  logic        jump_target_tag;
+  logic [ALU_MODE_WIDTH-1:0] alu_operator_mode;
+  logic        is_store;
+  logic        enable_a;
+  logic        enable_b;
+  logic        branch_taken_ex_tag;
+  logic        regfile_dest_tag;
+  logic        regfile_enable_tag;
+  logic        check_s1_tag;
+  logic        check_s2_tag;
+  logic        check_d_tag;
+  logic        execute_pc_tag;
+  logic        exception_tag;
+  logic        register_set_tag;
+  logic        is_store_post_tag;
+  logic        memory_set_tag;
+`endif
 
   assign instr = instr_rdata_i;
 
@@ -425,14 +486,15 @@ module riscv_id_stage
   assign reg_d_alu_is_reg_b_id = (regfile_alu_waddr_fw_i == regfile_addr_rb_id) && (regb_used_dec == 1'b1) && (regfile_addr_rb_id != '0);
   assign reg_d_alu_is_reg_c_id = (regfile_alu_waddr_fw_i == regfile_addr_rc_id) && (regc_used_dec == 1'b1) && (regfile_addr_rc_id != '0);
 
-
-
   // kill instruction in the IF/ID stage by setting the instr_valid_id control
   // signal to 0 for instructions that are done
   assign clear_instr_valid_o = id_ready_o | halt_id;
 
   assign branch_taken_ex = branch_in_ex_o & branch_decision_i;
 
+`ifdef DIFT
+  assign branch_taken_ex_tag = branch_in_ex_o & pc_enable_i_tag;
+`endif
 
   assign mult_en = mult_int_en | mult_dot_en;
 
@@ -466,7 +528,6 @@ module riscv_id_stage
     endcase
   end
 
-
   // hwloop cnt mux
   always_comb
   begin : hwloop_cnt_mux
@@ -483,7 +544,6 @@ module riscv_id_stage
   assign hwloop_regid = (|hwloop_we_int) ? hwloop_regid_int : csr_hwlp_regid_i;
   assign hwloop_we    = (|hwloop_we_int) ? hwloop_we_int    : csr_hwlp_we_i;
 
-
   //////////////////////////////////////////////////////////////////
   //      _                         _____                    _    //
   //     | |_   _ _ __ ___  _ __   |_   _|_ _ _ __ __ _  ___| |_  //
@@ -505,8 +565,21 @@ module riscv_id_stage
     endcase
   end
 
-  assign jump_target_o = jump_target;
+  assign jump_target_o = jump_target; // To ID
+
+`ifdef DIFT
+  always_comb
+  begin : jump_target_mux_tag
+    unique case (jump_target_mux_sel)
+      JT_JAL:  jump_target_tag = pc_id_i_tag;
+      JT_COND: jump_target_tag = pc_id_i_tag;
+      JT_JALR: jump_target_tag = regfile_data_ra_id_tag;
+      default: jump_target_tag = regfile_data_ra_id_tag;
+    endcase
+  end
 
+  assign jump_target_o_tag = jump_target_tag; // To ID
+`endif
 
   ////////////////////////////////////////////////////////
   //   ___                                 _      _     //
@@ -549,6 +622,31 @@ module riscv_id_stage
     endcase; // case (operand_a_fw_mux_sel)
   end
 
+`ifdef DIFT
+    // ALU_Op_a Mux
+    always_comb
+    begin : alu_operand_a_mux_tag
+      case (alu_op_a_mux_sel)
+        OP_A_REGA_OR_FWD:  alu_operand_a_tag = operand_a_fw_id_tag;
+        OP_A_REGB_OR_FWD:  alu_operand_a_tag = operand_b_fw_id_tag;
+        OP_A_CURRPC:       alu_operand_a_tag = pc_id_i_tag;
+        OP_A_IMM:          alu_operand_a_tag = 1'b0;
+        default:            alu_operand_a_tag = operand_a_fw_id_tag;
+      endcase;
+    end
+
+    // Operand a forwarding mux
+    always_comb
+    begin : operand_a_fw_mux_tag
+      case (operand_a_fw_mux_sel)
+        SEL_FW_EX:    operand_a_fw_id_tag = regfile_alu_wdata_fw_i_tag;
+        SEL_FW_WB:    operand_a_fw_id_tag = regfile_wdata_wb_i_tag;
+        SEL_REGFILE:  operand_a_fw_id_tag = regfile_data_ra_id_tag;
+        default:       operand_a_fw_id_tag = regfile_data_ra_id_tag;
+      endcase;
+    end
+`endif
+
   //////////////////////////////////////////////////////
   //   ___                                 _   ____   //
   //  / _ \ _ __   ___ _ __ __ _ _ __   __| | | __ )  //
@@ -586,11 +684,10 @@ module riscv_id_stage
       OP_B_REGB_OR_FWD:  operand_b = operand_b_fw_id;
       OP_B_REGC_OR_FWD:  operand_b = operand_c_fw_id;
       OP_B_IMM:          operand_b = imm_b;
-      default:           operand_b = operand_b_fw_id;
+      default:            operand_b = operand_b_fw_id;
     endcase // case (alu_op_b_mux_sel)
   end
 
-
   // scalar replication for operand B and shuffle type
   always_comb
   begin
@@ -606,7 +703,6 @@ module riscv_id_stage
   // choose normal or scalar replicated version of operand b
   assign alu_operand_b = (scalar_replication == 1'b1) ? operand_b_vec : operand_b;
 
-
   // Operand b forwarding mux
   always_comb
   begin : operand_b_fw_mux
@@ -618,6 +714,45 @@ module riscv_id_stage
     endcase; // case (operand_b_fw_mux_sel)
   end
 
+`ifdef DIFT
+    // ALU_Op_b Mux
+    always_comb
+    begin : alu_operand_b_mux_tag
+      case (alu_op_b_mux_sel)
+        OP_B_REGB_OR_FWD:  operand_b_tag = operand_b_fw_id_tag;
+        OP_B_REGC_OR_FWD:  operand_b_tag = operand_c_fw_id_tag;
+        OP_B_IMM:          operand_b_tag = 1'b0;
+        default:            operand_b_tag = operand_b_fw_id_tag;
+      endcase // case (alu_op_b_mux_sel)
+    end
+
+    /* scalar replication for operand B and shuffle type
+    always_comb
+    begin
+      if (alu_vec_mode == VEC_MODE8) begin
+        operand_b_vec    = {4{operand_b[7:0]}};
+        imm_shuffle_type = imm_shuffleb_type;
+      end else begin
+        operand_b_vec    = {2{operand_b[15:0]}};
+        imm_shuffle_type = imm_shuffleh_type;
+      end
+    end*/
+
+    // choose normal or scalar replicated version of operand b
+    // assign alu_operand_b = (scalar_replication == 1'b1) ? operand_b_vec : operand_b;
+    assign alu_operand_b_tag = operand_b_tag;
+
+    // Operand b forwarding mux
+    always_comb
+    begin : operand_b_fw_mux_tag
+      case (operand_b_fw_mux_sel)
+        SEL_FW_EX:    operand_b_fw_id_tag = regfile_alu_wdata_fw_i_tag;
+        SEL_FW_WB:    operand_b_fw_id_tag = regfile_wdata_wb_i_tag;
+        SEL_REGFILE:  operand_b_fw_id_tag = regfile_data_rb_id_tag;
+        default:       operand_b_fw_id_tag = regfile_data_rb_id_tag;
+      endcase; // case (operand_b_fw_mux_sel)
+    end
+`endif
 
   //////////////////////////////////////////////////////
   //   ___                                 _    ____  //
@@ -634,7 +769,7 @@ module riscv_id_stage
     case (alu_op_c_mux_sel)
       OP_C_REGC_OR_FWD:  alu_operand_c = operand_c_fw_id;
       OP_C_REGB_OR_FWD:  alu_operand_c = operand_b_fw_id;
-      OP_C_JT:           alu_operand_c = jump_target;
+      OP_C_JT:           alu_operand_c = jump_target; // To EX
       default:            alu_operand_c = operand_c_fw_id;
     endcase // case (alu_op_c_mux_sel)
   end
@@ -650,6 +785,29 @@ module riscv_id_stage
     endcase; // case (operand_c_fw_mux_sel)
   end
 
+`ifdef DIFT
+    // ALU OP C Mux
+    always_comb
+    begin : alu_operand_c_mux_tag
+      case (alu_op_c_mux_sel)
+        OP_C_REGC_OR_FWD:  alu_operand_c_tag = operand_c_fw_id_tag;
+        OP_C_REGB_OR_FWD:  alu_operand_c_tag = operand_b_fw_id_tag;
+        OP_C_JT:           alu_operand_c_tag = jump_target_tag; // To EX
+        default:            alu_operand_c_tag = operand_c_fw_id_tag;
+      endcase // case (alu_op_c_mux_sel)
+    end
+
+    // Operand c forwarding mux
+    always_comb
+    begin : operand_c_fw_mux_tag
+      case (operand_c_fw_mux_sel)
+        SEL_FW_EX:    operand_c_fw_id_tag = regfile_alu_wdata_fw_i_tag;
+        SEL_FW_WB:    operand_c_fw_id_tag = regfile_wdata_wb_i_tag;
+        SEL_REGFILE:  operand_c_fw_id_tag = regfile_data_rc_id_tag;
+        default:       operand_c_fw_id_tag = regfile_data_rc_id_tag;
+      endcase; // case (operand_c_fw_mux_sel)
+    end
+`endif
 
   ///////////////////////////////////////////////////////////////////////////
   //  ___                              _ _       _              ___ ____   //
@@ -681,7 +839,6 @@ module riscv_id_stage
 
   assign imm_vec_ext_id = imm_vu_type[1:0];
 
-
   always_comb
   begin
     unique case (mult_imm_mux)
@@ -699,6 +856,7 @@ module riscv_id_stage
   // |_| \_\_____\____|___|____/ |_| |_____|_| \_\____/  //
   //                                                     //
   /////////////////////////////////////////////////////////
+
   riscv_register_file  registers_i
   (
     .clk          ( clk                ),
@@ -731,6 +889,46 @@ module riscv_id_stage
 
   assign dbg_reg_rdata_o = regfile_data_rc_id;
 
+ //////////////////////////////////////////////////////////////////////////////////
+ //  ____  _____ ____ ___ ____ _____ _____ ____  ____    _____  _    ____ ____   //
+ // |  _ \| ____/ ___|_ _/ ___|_   _| ____|  _ \/ ___|  |_   _|/ \  / ___/ ___|  //
+ // | |_) |  _|| |  _ | |\___ \ | | |  _| | |_) \___ \    | | / _ \| |  _\___ \  //
+ // |  _ <| |__| |_| || | ___) || | | |___|  _ < ___) |   | |/ ___ \ |_| |___) | //
+ // |_| \_\_____\____|___|____/ |_| |_____|_| \_\____/    |_/_/   \_\____|____/  //
+ //                                                                              //
+ //////////////////////////////////////////////////////////////////////////////////
+
+`ifdef DIFT
+  riscv_register_file_tag  registers_i_tag
+  (
+    .clk          ( clk                ),
+    .rst_n        ( rst_n              ),
+
+    .test_en_i    ( test_en_i          ),
+
+    // Read port a
+    .raddr_a_i    ( regfile_addr_ra_id ),
+    .rdata_a_o    ( regfile_data_ra_id_tag ),
+
+    // Read port b
+    .raddr_b_i    ( regfile_addr_rb_id ),
+    .rdata_b_o    ( regfile_data_rb_id_tag ),
+
+    // Read port c
+    .raddr_c_i    ( regfile_addr_rc_id ),
+    .rdata_c_o    ( regfile_data_rc_id_tag ),
+
+    // Write port a
+    .waddr_a_i    ( regfile_waddr_wb_i ),
+    .wdata_a_i    ( regfile_dest_tag   ),
+    .we_a_i       ( regfile_enable_tag ),
+
+    // Write port b
+    .waddr_b_i    ( regfile_alu_waddr_fw_i_tag ),
+    .wdata_b_i    ( regfile_alu_wdata_fw_i_tag ),
+    .we_b_i       ( regfile_alu_we_fw_i_tag )
+  );
+`endif
 
   ///////////////////////////////////////////////
   //  ____  _____ ____ ___  ____  _____ ____   //
@@ -814,8 +1012,136 @@ module riscv_id_stage
     .jump_in_dec_o                   ( jump_in_dec               ),
     .jump_in_id_o                    ( jump_in_id                ),
     .jump_target_mux_sel_o           ( jump_target_mux_sel       )
+  );
+
+  ////////////////////////////////////////////////////////////////////////////
+  //   __  __  ___  ____  _____   ____  _____ ____ ___  ____  _____ ____    //
+  //  |  \/  |/ _ \|  _ \| ____| |  _ \| ____/ ___/ _ \|  _ \| ____|  _ \   //
+  //  | |\/| | | | | | | |  _|   | | | |  _|| |  | | | | | | |  _| | |_) |  //
+  //  | |  | | |_| | |_| | |___  | |_| | |__| |__| |_| | |_| | |___|  _ <   //
+  //  |_|  |_|\___/|____/|_____| |____/|_____\____\___/|____/|_____|_| \_\  //
+  //                                                                        //
+  ////////////////////////////////////////////////////////////////////////////
+
+`ifdef DIFT
+  riscv_mode_tag mode_i_tag
+  (
+    .instr_rdata_i                   ( instr                     ),
+    .tpr_i                           ( tpr_i                     ),
+
+    // jump/branches
+    .alu_operator_o_mode             ( alu_operator_mode         ),
+    .register_set_o                  ( register_set_tag          ),
+    .is_store_post_o                 ( is_store_post_tag         ),
+    .memory_set_o                    ( memory_set_tag            )
+  );
+`endif
+
+  /////////////////////////////////////////////////
+  //   _____ _   _    _    ____  _     _____     //
+  //  | ____| \ | |  / \  | __ )| |   | ____|    //
+  //  |  _| |  \| | / _ \ |  _ \| |   |  _|      //
+  //  | |___| |\  |/ ___ \| |_) | |___| |___     //
+  //  |_____|_| \_/_/   \_\____/|_____|_____|    //
+  //                                             //
+  //   ____  _____ ____ ___  ____  _____ ____    //
+  //  |  _ \| ____/ ___/ _ \|  _ \| ____|  _ \   //
+  //  | | | |  _|| |  | | | | | | |  _| | |_) |  //
+  //  | |_| | |__| |__| |_| | |_| | |___|  _ <   //
+  //  |____/|_____\____\___/|____/|_____|_| \_\  //
+  //                                             //
+  /////////////////////////////////////////////////
+
+`ifdef DIFT
+  riscv_enable_tag enable_i_tag
+  (
+    .instr_rdata_i                   ( instr                     ),
+    .tpr_i                           ( tpr_i                     ),
+    .is_store_o                      ( is_store                  ),
+    .enable_a_o                      ( enable_a                  ),
+    .enable_b_o                      ( enable_b                  )
+  );
+`endif
 
+  ///////////////////////////////////////////////////////////////////////
+  //   _     ___    _    ____                                          //
+  //  | |   / _ \  / \  |  _ \                                         //
+  //  | |  | | | |/ _ \ | | | |                                        //
+  //  | |__| |_| / ___ \| |_| |                                        //
+  //  |_____\___/_/   \_\____/                                         //
+  //                                                                   //
+  //  ____  ____   ___  ____   _    ____    _  _____ ___ ___  _   _    //
+  //  |  _ \|  _ \ / _ \|  _ \ / \  / ___|  / \|_   _|_ _/ _ \| \ | |  //
+  //  | |_) | |_) | | | | |_) / _ \| |  _  / _ \ | |  | | | | |  \| |  //
+  //  |  __/|  _ <| |_| |  __/ ___ \ |_| |/ ___ \| |  | | |_| | |\  |  //
+  //  |_|   |_| \_\\___/|_| /_/   \_\____/_/   \_\_| |___\___/|_| \_|  //
+  //                                                                   //
+  ///////////////////////////////////////////////////////////////////////
+
+`ifdef DIFT
+  riscv_load_propagation load_i_propagation
+  (
+    .regfile_wdata_wb_i_tag          ( regfile_wdata_wb_i_tag    ),
+    .rs1_i_tag                       ( rs1_i_tag                 ),
+    .regfile_we_wb_i                 ( regfile_we_wb_i           ),
+    .tpr_i                           ( tpr_i                     ),
+    .regfile_dest_tag                ( regfile_dest_tag          ),
+    .regfile_enable_tag              ( regfile_enable_tag        )
   );
+`endif
+
+  ///////////////////////////////////////////////////////////////
+  //   _     ___    _    ____     ____ _   _ _____ ____ _  __  //
+  //  | |   / _ \  / \  |  _ \   / ___| | | | ____/ ___| |/ /  //
+  //  | |  | | | |/ _ \ | | | | | |   | |_| |  _|| |   | ' /   //
+  //  | |__| |_| / ___ \| |_| | | |___|  _  | |__| |___| . \   //
+  //  |_____\___/_/   \_\____/   \____|_| |_|_____\____|_|\_\  //
+  //                                                           //
+  ///////////////////////////////////////////////////////////////
+
+`ifdef DIFT
+  riscv_load_check load_i_check
+  (
+    .regfile_wdata_wb_i_tag          ( regfile_wdata_wb_i_tag    ),
+    .rs1_i_tag                       ( rs1_i_tag                 ),
+    .regfile_dest_tag                ( regfile_dest_tag          ),
+    .tcr_i                           ( tcr_i                     ),
+    .regfile_we_wb_i                 ( regfile_we_wb_i           ),
+    .exception_o                     ( exception_tag             )
+    `ifdef DIFT_H
+    ,
+    .thr_i                           ( thr_i                     ),
+    .regfile_wdata_wb_i_htag         ( regfile_wdata_wb_i_htag   )
+    `endif
+  );
+`endif
+
+  //////////////////////////////////////////////////////////////////////////////
+  //   ____ _   _ _____ ____ _  __  ____  _____ ____ ___  ____  _____ ____    //
+  //  / ___| | | | ____/ ___| |/ / |  _ \| ____/ ___/ _ \|  _ \| ____|  _ \   //
+  // | |   | |_| |  _|| |   | ' /  | | | |  _|| |  | | | | | | |  _| | |_) |  //
+  // | |___|  _  | |__| |___| . \  | |_| | |__| |__| |_| | |_| | |___|  _ <   //
+  //  \____|_| |_|_____\____|_|\_\ |____/|_____\____\___/|____/|_____|_| \_\  //
+  //                                                                          //
+  //////////////////////////////////////////////////////////////////////////////
+
+`ifdef DIFT
+  riscv_check_tag check_i_tag
+  (
+    .instr_rdata_i                   ( instr                     ),
+    .tcr_i                           ( tcr_i                     ),
+    .source_1_o                      ( check_s1_tag              ),
+    .source_2_o                      ( check_s2_tag              ),
+    .dest_o                          ( check_d_tag               ),
+    .execute_pc_o                    ( execute_pc_tag            )
+  );
+`endif
+
+`ifdef DIFT
+  assign illegal_insn_dec_dift = illegal_insn_dec | exception_tag | exception_i_tag | (execute_pc_tag & pc_id_i_tag);
+`else
+  assign illegal_insn_dec_dift = illegal_insn_dec;
+`endif
 
   ////////////////////////////////////////////////////////////////////
   //    ____ ___  _   _ _____ ____   ___  _     _     _____ ____    //
@@ -837,7 +1163,7 @@ module riscv_id_stage
 
     // decoder related signals
     .deassert_we_o                  ( deassert_we            ),
-    .illegal_insn_i                 ( illegal_insn_dec       ),
+    .illegal_insn_i                 ( illegal_insn_dec_dift  ),
     .eret_insn_i                    ( eret_insn_dec          ),
     .pipe_flush_i                   ( pipe_flush_dec         ),
 
@@ -855,6 +1181,9 @@ module riscv_id_stage
     // to prefetcher
     .pc_set_o                       ( pc_set_o               ),
     .pc_mux_o                       ( pc_mux_o               ),
+`ifdef DIFT
+    .pc_set_o_tag                   ( pc_set_o_tag           ),
+`endif
 
     // LSU
     .data_req_ex_i                  ( data_req_ex_o          ),
@@ -866,6 +1195,9 @@ module riscv_id_stage
 
     // jump/branch control
     .branch_taken_ex_i              ( branch_taken_ex        ),
+`ifdef DIFT
+    .branch_taken_ex_i_tag          ( branch_taken_ex_tag    ),
+`endif
     .jump_in_id_i                   ( jump_in_id             ),
     .jump_in_dec_i                  ( jump_in_dec            ),
 
@@ -957,10 +1289,10 @@ module riscv_id_stage
     .irq_i                ( irq_i            ),
     .irq_enable_i         ( irq_enable_i     ),
 
-    .ebrk_insn_i          ( is_decoding_o & ebrk_insn        ),
-    .illegal_insn_i       ( is_decoding_o & illegal_insn_dec ),
-    .ecall_insn_i         ( is_decoding_o & ecall_insn_dec   ),
-    .eret_insn_i          ( is_decoding_o & eret_insn_dec    ),
+    .ebrk_insn_i          ( is_decoding_o & ebrk_insn             ),
+    .illegal_insn_i       ( is_decoding_o & illegal_insn_dec_dift ),
+    .ecall_insn_i         ( is_decoding_o & ecall_insn_dec        ),
+    .eret_insn_i          ( is_decoding_o & eret_insn_dec         ),
 
     .lsu_load_err_i       ( lsu_load_err_i   ),
     .lsu_store_err_i      ( lsu_store_err_i  ),
@@ -971,7 +1303,6 @@ module riscv_id_stage
     .dbg_settings_i       ( dbg_settings_i   )
   );
 
-
   //////////////////////////////////////////////////////////////////////////
   //          ____ ___  _   _ _____ ____   ___  _     _     _____ ____    //
   //         / ___/ _ \| \ | |_   _|  _ \ / _ \| |   | |   | ____|  _ \   //
@@ -1070,7 +1401,6 @@ module riscv_id_stage
       pc_ex_o                     <= '0;
 
       branch_in_ex_o              <= 1'b0;
-
     end
     else if (data_misaligned_i) begin
       // misaligned data access case
@@ -1101,14 +1431,14 @@ module riscv_id_stage
       begin // unstall the whole pipeline
         if (~mult_en)
         begin // only change those registers when we actually need to
-          alu_operator_ex_o         <= alu_operator;
-          alu_operand_a_ex_o        <= alu_operand_a;
-          alu_operand_b_ex_o        <= alu_operand_b;
-          alu_operand_c_ex_o        <= alu_operand_c;
-          bmask_a_ex_o              <= bmask_a_id;
-          bmask_b_ex_o              <= bmask_b_id;
-          imm_vec_ext_ex_o          <= imm_vec_ext_id;
-          alu_vec_mode_ex_o         <= alu_vec_mode;
+          alu_operator_ex_o           <= alu_operator;
+          alu_operand_a_ex_o          <= alu_operand_a;
+          alu_operand_b_ex_o          <= alu_operand_b;
+          alu_operand_c_ex_o          <= alu_operand_c;
+          bmask_a_ex_o                <= bmask_a_id;
+          bmask_b_ex_o                <= bmask_b_id;
+          imm_vec_ext_ex_o            <= imm_vec_ext_id;
+          alu_vec_mode_ex_o           <= alu_vec_mode;
         end
 
         mult_en_ex_o                <= mult_en;
@@ -1183,12 +1513,85 @@ module riscv_id_stage
     end
   end
 
+`ifdef DIFT
+  always_ff @(posedge clk, negedge rst_n)
+  begin : ID_EX_PIPE_REGISTERS_TAG
+    if (rst_n == 1'b0)
+    begin
+      alu_operator_o_mode         <= ALU_MODE_OLD;
+      alu_operand_a_ex_o_tag      <= '0;
+      alu_operand_b_ex_o_tag      <= '0;
+      alu_operand_c_ex_o_tag      <= '0;
+      pc_ex_o_tag                 <= '0;
+      check_s1_o_tag              <= '0;
+      check_s2_o_tag              <= '0;
+      check_d_o_tag               <= '0;
+      register_set_o_tag          <= '0;
+      is_store_post_o_tag         <= '0;
+      memory_set_o_tag            <= '0;
+      regfile_alu_waddr_ex_o_tag  <= '0;
+      store_dest_addr_ex_o_tag    <= '0;
+      store_source_ex_o_tag       <= '0;
+      use_store_ops_ex_o          <= '0;
+    end
+    else if (data_misaligned_i) begin
+      if (ex_ready_i)
+      begin
+        alu_operand_a_ex_o_tag    <= alu_operand_a_tag;
+        alu_operand_b_ex_o_tag    <= alu_operand_b_tag;
+      end
+    end else begin
+      if (id_valid_o)
+      begin
+        if (~mult_en)
+        begin
+          alu_operator_o_mode           <= alu_operator_mode;
+          check_s1_o_tag                <= check_s1_tag;
+          check_s2_o_tag                <= check_s2_tag;
+          check_d_o_tag                 <= check_d_tag;
+          register_set_o_tag            <= register_set_tag;
+          is_store_post_o_tag           <= is_store_post_tag;
+          memory_set_o_tag              <= memory_set_tag;
+          if (is_store) begin
+            if (enable_a) begin
+              alu_operand_a_ex_o_tag    <= alu_operand_a_tag;  // RS1: destination address tag
+            end else begin
+              alu_operand_a_ex_o_tag    <= '0;
+            end
+	          if (enable_b) begin
+	            alu_operand_b_ex_o_tag    <= alu_operand_c_tag;  // RS2: source tag
+            end else begin
+              alu_operand_b_ex_o_tag    <= '0;
+            end
+            store_dest_addr_ex_o_tag    <= alu_operand_a_tag;  // RS1: destination address tag
+            store_source_ex_o_tag       <= alu_operand_c_tag;  // RS2: source tag
+            use_store_ops_ex_o          <= '1;
+          end else begin
+            alu_operand_a_ex_o_tag      <= alu_operand_a_tag;
+            alu_operand_b_ex_o_tag      <= alu_operand_b_tag;
+            alu_operand_c_ex_o_tag      <= alu_operand_c_tag;
+            store_dest_addr_ex_o_tag    <= '0;
+            store_source_ex_o_tag       <= '0;
+            use_store_ops_ex_o          <= '0;
+          end
+        end
+
+        if (regfile_alu_we_id || register_set_tag) begin
+          regfile_alu_waddr_ex_o_tag    <= regfile_alu_waddr_id;
+        end
+
+        if ((jump_in_id == BRANCH_COND) || data_load_event_id) begin
+          pc_ex_o_tag               <= pc_id_i_tag;
+        end
+      end
+    end
+  end
+`endif
 
   // stall control
   assign id_ready_o = ((~misaligned_stall) & (~jr_stall) & (~load_stall) & ex_ready_i);
   assign id_valid_o = (~halt_id) & id_ready_o;
 
-
   //----------------------------------------------------------------------------
   // Assertions
   //----------------------------------------------------------------------------
diff --git a/if_stage.sv b/if_stage.sv
index 60d181d..b50d8db 100644
--- a/if_stage.sv
+++ b/if_stage.sv
@@ -25,6 +25,7 @@
 //                                                                            //
 ////////////////////////////////////////////////////////////////////////////////
 
+`include "riscv_config.sv"
 
 import riscv_defines::*;
 
@@ -34,62 +35,70 @@ module riscv_if_stage
   parameter RDATA_WIDTH = 32
 )
 (
-    input  logic        clk,
-    input  logic        rst_n,
-
-    // the boot address is used to calculate the exception offsets
-    input  logic [31:0] boot_addr_i,
-
-    // instruction request control
-    input  logic        req_i,
-
-    // instruction cache interface
-    output logic                   instr_req_o,
-    output logic            [31:0] instr_addr_o,
-    input  logic                   instr_gnt_i,
-    input  logic                   instr_rvalid_i,
-    input  logic [RDATA_WIDTH-1:0] instr_rdata_i,
-
-    // Output of IF Pipeline stage
-    output logic [N_HWLP-1:0] hwlp_dec_cnt_id_o,     // currently served instruction was the target of a hwlp
-    output logic              is_hwlp_id_o,          // currently served instruction was the target of a hwlp
-    output logic              instr_valid_id_o,      // instruction in IF/ID pipeline is valid
-    output logic       [31:0] instr_rdata_id_o,      // read instruction is sampled and sent to ID stage for decoding
-    output logic              is_compressed_id_o,    // compressed decoder thinks this is a compressed instruction
-    output logic              illegal_c_insn_id_o,   // compressed decoder thinks this is an invalid instruction
-    output logic       [31:0] pc_if_o,
-    output logic       [31:0] pc_id_o,
-
-    // Forwarding ports - control signals
-    input  logic        clear_instr_valid_i,   // clear instruction valid bit in IF/ID pipe
-    input  logic        pc_set_i,              // set the program counter to a new value
-    input  logic [31:0] exception_pc_reg_i,    // address used to restore PC when the interrupt/exception is served
-    input  logic  [2:0] pc_mux_i,              // sel for pc multiplexer
-    input  logic  [1:0] exc_pc_mux_i,          // selects ISR address
-    input  logic  [4:0] exc_vec_pc_mux_i,      // selects ISR address for vectorized interrupt lines
-
-    // jump and branch target and decision
-    input  logic [31:0] jump_target_id_i,      // jump target address
-    input  logic [31:0] jump_target_ex_i,      // jump target address
-
-    // from hwloop controller
-    input  logic [N_HWLP-1:0] [31:0] hwlp_start_i,          // hardware loop start addresses
-    input  logic [N_HWLP-1:0] [31:0] hwlp_end_i,            // hardware loop end addresses
-    input  logic [N_HWLP-1:0] [31:0] hwlp_cnt_i,            // hardware loop counters
-
-    // from debug unit
-    input  logic [31:0] dbg_jump_addr_i,
-    input  logic        dbg_jump_req_i,
-
-    // pipeline stall
-    input  logic        halt_if_i,
-    output logic        if_ready_o,
-    input  logic        id_ready_i,
-    output logic        if_valid_o,
-
-    // misc signals
-    output logic        if_busy_o,             // is the IF stage busy fetching instructions?
-    output logic        perf_imiss_o           // Instruction Fetch Miss
+  input  logic        clk,
+  input  logic        rst_n,
+
+  // the boot address is used to calculate the exception offsets
+  input  logic [31:0] boot_addr_i,
+
+  // instruction request control
+  input  logic        req_i,
+
+  // instruction cache interface
+  output logic                   instr_req_o,
+  output logic            [31:0] instr_addr_o,
+  input  logic                   instr_gnt_i,
+  input  logic                   instr_rvalid_i,
+  input  logic [RDATA_WIDTH-1:0] instr_rdata_i,
+
+  // Output of IF Pipeline stage
+  output logic [N_HWLP-1:0] hwlp_dec_cnt_id_o,     // currently served instruction was the target of a hwlp
+  output logic              is_hwlp_id_o,          // currently served instruction was the target of a hwlp
+  output logic              instr_valid_id_o,      // instruction in IF/ID pipeline is valid
+  output logic       [31:0] instr_rdata_id_o,      // read instruction is sampled and sent to ID stage for decoding
+  output logic              is_compressed_id_o,    // compressed decoder thinks this is a compressed instruction
+  output logic              illegal_c_insn_id_o,   // compressed decoder thinks this is an invalid instruction
+  output logic       [31:0] pc_if_o,
+  output logic       [31:0] pc_id_o,
+
+  // Forwarding ports - control signals
+  input  logic        clear_instr_valid_i,   // clear instruction valid bit in IF/ID pipe
+  input  logic        pc_set_i,              // set the program counter to a new value
+  input  logic [31:0] exception_pc_reg_i,    // address used to restore PC when the interrupt/exception is served
+  input  logic  [2:0] pc_mux_i,              // sel for pc multiplexer
+  input  logic  [1:0] exc_pc_mux_i,          // selects ISR address
+  input  logic  [4:0] exc_vec_pc_mux_i,      // selects ISR address for vectorized interrupt lines
+
+  // jump and branch target and decision
+  input  logic [31:0] jump_target_id_i,      // jump target address
+  input  logic [31:0] jump_target_ex_i,      // branch target address
+
+  // from hwloop controller
+  input  logic [N_HWLP-1:0] [31:0] hwlp_start_i,          // hardware loop start addresses
+  input  logic [N_HWLP-1:0] [31:0] hwlp_end_i,            // hardware loop end addresses
+  input  logic [N_HWLP-1:0] [31:0] hwlp_cnt_i,            // hardware loop counters
+
+  // from debug unit
+  input  logic [31:0] dbg_jump_addr_i,
+  input  logic        dbg_jump_req_i,
+
+  // pipeline stall
+  input  logic        halt_if_i,
+  output logic        if_ready_o,
+  input  logic        id_ready_i,
+  output logic        if_valid_o,
+
+  // misc signals
+  output logic        if_busy_o,             // is the IF stage busy fetching instructions?
+  output logic        perf_imiss_o           // Instruction Fetch Miss
+
+`ifdef DIFT
+  ,
+  input  logic        jump_target_id_i_tag,
+  input  logic        jump_target_ex_i_tag,
+  input  logic        pc_set_i_tag,
+  output logic        pc_id_o_tag
+`endif
 );
 
   // offset FSM
@@ -115,6 +124,10 @@ module riscv_if_stage
   logic       [31:0] hwlp_target;
   logic [N_HWLP-1:0] hwlp_dec_cnt, hwlp_dec_cnt_if;
 
+`ifdef DIFT
+  logic              fetch_addr_n_tag;
+  logic              pc_if_o_tag;
+`endif
 
   // exception PC selection mux
   always_comb
@@ -149,6 +162,20 @@ module riscv_if_stage
     endcase
   end
 
+`ifdef DIFT
+  always_comb
+  begin
+    fetch_addr_n_tag = 1'b0;
+
+    unique case (pc_mux_i)
+      PC_BOOT:      fetch_addr_n_tag = 1'b0;
+      PC_JUMP:      fetch_addr_n_tag = jump_target_id_i_tag;
+      PC_BRANCH:    fetch_addr_n_tag = jump_target_ex_i_tag;
+      default:      fetch_addr_n_tag = 1'b0;
+    endcase
+  end
+`endif
+
   generate
     if (RDATA_WIDTH == 32) begin : prefetch_32
       // prefetch buffer, caches a fixed number of instructions
@@ -302,6 +329,18 @@ module riscv_if_stage
 
   assign perf_imiss_o    = (~fetch_valid) | branch_req;
 
+`ifdef DIFT
+  always_ff @(posedge clk, negedge rst_n)
+  begin
+    if (rst_n == 1'b0)
+    begin
+      pc_if_o_tag <= 1'b0;
+    end else if (pc_set_i_tag) begin
+      pc_if_o_tag <= fetch_addr_n_tag;
+    end
+  end
+`endif
+
 
   // compressed instruction decoding, or more precisely compressed instruction
   // expander
@@ -369,6 +408,21 @@ module riscv_if_stage
     end
   end
 
+`ifdef DIFT
+  always_ff @(posedge clk, negedge rst_n)
+  begin
+    if (rst_n == 1'b0)
+    begin
+      pc_id_o_tag           <= 1'b0;
+    end else begin
+      if (if_valid_o)
+      begin
+        pc_id_o_tag         <= pc_if_o_tag;
+      end
+    end
+  end
+`endif
+
   assign is_hwlp_id_o = is_hwlp_id_q & instr_valid_id_o;
 
   assign if_ready_o = valid & id_ready_i;
diff --git a/include/riscv_config.sv b/include/riscv_config.sv
index 7137bae..3fd2afb 100644
--- a/include/riscv_config.sv
+++ b/include/riscv_config.sv
@@ -28,3 +28,9 @@
 `endif
 //`define SIMCHECKER
 `endif
+
+//Ligne ci-dessous à commenter lors d'une compilation du RI5CY seul
+`define DIFT 1
+
+//ligne ci-dessous à décommenter pour utiliser le DIFT étendu à la mémoire
+`define DIFT_H 1
\ No newline at end of file
diff --git a/include/riscv_defines.sv b/include/riscv_defines.sv
index 7a83e27..477d9dd 100644
--- a/include/riscv_defines.sv
+++ b/include/riscv_defines.sv
@@ -61,6 +61,9 @@ parameter REGC_S1   = 2'b10;
 parameter REGC_RD   = 2'b01;
 parameter REGC_ZERO = 2'b11;
 
+// DIFT custom
+parameter OPCODE_DIFT_STORE = 7'h1b;
+
 
 //////////////////////////////////////////////////////////////////////////////
 //      _    _    _   _    ___                       _   _                  //
@@ -166,6 +169,102 @@ parameter VEC_MODE32 = 2'b00;
 parameter VEC_MODE16 = 2'b10;
 parameter VEC_MODE8  = 2'b11;
 
+////////////////////////////////////
+//   ____ _   _ _____ ____ _  __  //
+//  / ___| | | | ____/ ___| |/ /  //
+// | |   | |_| |  _|| |   | ' /   //
+// | |___|  _  | |__| |___| . \   //
+//  \____|_| |_|_____\____|_|\_\  //
+//                                //
+////////////////////////////////////
+
+// Integer class: ADDI, ADD, SUB, MUL, MULD[[S]U], MULW, DIV[U], REM[U], DIV[U]W, REM[U]W
+parameter INTEGER_CHECK_S1      = 0;
+parameter INTEGER_CHECK_S2      = 1;
+parameter INTEGER_CHECK_D       = 2;
+// Branch class: BEQ, BNE, BLT[U], BGE[U]
+parameter BRANCH_CHECK_S1       = 3;
+parameter BRANCH_CHECK_S2       = 4;
+// Jump class: JAL, JALR
+parameter JUMP_CHECK_S1         = 5;
+parameter JUMP_CHECK_S2         = 6;
+parameter JUMP_CHECK_D          = 7;
+// Shift class: SLLI, SRLI, SRAI, SLL, SRL, SRA
+parameter SHIFT_CHECK_S1        = 8;
+parameter SHIFT_CHECK_S2        = 9;
+parameter SHIFT_CHECK_D         = 10;
+// Comparison class: SLTI[U], SLT[U]
+parameter COMPARISON_CHECK_S1   = 11;
+parameter COMPARISON_CHECK_S2   = 12;
+parameter COMPARISON_CHECK_D    = 13;
+// Logical class: ANDI, ORI, XORI, AND, OR, XOR
+parameter LOGICAL_CHECK_S1      = 14;
+parameter LOGICAL_CHECK_S2      = 15;
+parameter LOGICAL_CHECK_D       = 16;
+// Load/Store class: LW, LH[U], LB[U], SW, SH, SB, LUI, AUIPC
+parameter LOADSTORE_CHECK_S     = 17;
+parameter LOADSTORE_CHECK_SA    = 18;
+parameter LOADSTORE_CHECK_D     = 19;
+parameter LOADSTORE_CHECK_DA    = 20;
+
+parameter THR_CURRENT_LOW = 0;
+parameter THR_CURRENT_HIGH = 1;
+parameter THR_BUFFER_LOW = 2;
+parameter THR_BUFFER_HIGH = 3;
+
+// Execute class: PC
+parameter EXECUTE_PC            = 21;
+
+///////////////////////////////////////////////
+//   _____ _   _    _    ____  _     _____   //
+//  | ____| \ | |  / \  | __ )| |   | ____|  //
+//  |  _| |  \| | / _ \ |  _ \| |   |  _|    //
+//  | |___| |\  |/ ___ \| |_) | |___| |___   //
+//  |_____|_| \_/_/   \_\____/|_____|_____|  //
+//                                           //
+///////////////////////////////////////////////
+
+parameter LOADSTORE_EN_SOURCE      = 15;
+parameter LOADSTORE_EN_SOURCE_ADDR = 16;
+parameter LOADSTORE_EN_DEST_ADDR   = 17;
+
+//////////////////////////////////
+//   __  __  ___  ____  _____   //
+//  |  \/  |/ _ \|  _ \| ____|  //
+//  | |\/| | | | | | | |  _|    //
+//  | |  | | |_| | |_| | |___   //
+//  |_|  |_|\___/|____/|_____|  //
+//                              //
+//////////////////////////////////
+
+parameter ALU_MODE_WIDTH = 2;
+
+parameter ALU_MODE_OLD    = 2'b00;
+parameter ALU_MODE_AND    = 2'b01;
+parameter ALU_MODE_OR     = 2'b10;
+parameter ALU_MODE_CLEAR  = 2'b11;
+
+// Integer class: ADDI, ADD, SUB, MUL, MULD[[S]U], MULW, DIV[U], REM[U], DIV[U]W, REM[U]W
+parameter INTEGER_LOW      = 0;
+parameter INTEGER_HIGH     = 1;
+// Branch class: BEQ, BNE, BLT[U], BGE[U]
+parameter BRANCH_LOW       = 2;
+parameter BRANCH_HIGH      = 3;
+// Jump class: JAL, JALR
+parameter JUMP_LOW         = 4;
+parameter JUMP_HIGH        = 5;
+// Shift class: SLLI, SRLI, SRAI, SLL, SRL, SRA
+parameter SHIFT_LOW        = 6;
+parameter SHIFT_HIGH       = 7;
+// Comparison class: SLTI[U], SLT[U]
+parameter COMPARISON_LOW   = 8;
+parameter COMPARISON_HIGH  = 9;
+// Logical class: ANDI, ORI, XORI, AND, OR, XOR
+parameter LOGICAL_LOW      = 10;
+parameter LOGICAL_HIGH     = 11;
+// Load/Store class: LW, LH[U], LB[U], SW, SH, SB, LUI, AUIPC
+parameter LOADSTORE_LOW    = 12;
+parameter LOADSTORE_HIGH   = 13;
 
 /////////////////////////////////////////////////////////
 //    ____ ____    ____            _     _             //
@@ -182,7 +281,6 @@ parameter CSR_OP_WRITE = 2'b01;
 parameter CSR_OP_SET   = 2'b10;
 parameter CSR_OP_CLEAR = 2'b11;
 
-
 // SPR for debugger, not accessible by CPU
 parameter SP_DVR0       = 16'h3000;
 parameter SP_DCR0       = 16'h3008;
@@ -194,7 +292,6 @@ parameter SP_DCR_MSB = 8'h01;
 parameter SP_DMR_MSB = 8'h02;
 parameter SP_DSR_MSB = 8'h04;
 
-
 ///////////////////////////////////////////////
 //   ___ ____    ____  _                     //
 //  |_ _|  _ \  / ___|| |_ __ _  __ _  ___   //
@@ -266,7 +363,6 @@ parameter JT_JAL  = 2'b01;
 parameter JT_JALR = 2'b10;
 parameter JT_COND = 2'b11;
 
-
 ///////////////////////////////////////////////
 //   ___ _____   ____  _                     //
 //  |_ _|  ___| / ___|| |_ __ _  __ _  ___   //
@@ -299,7 +395,6 @@ parameter EXC_OFF_ILLINSN  = 8'h84;
 parameter EXC_OFF_ECALL    = 8'h88;
 parameter EXC_OFF_LSUERR   = 8'h8c;
 
-
 // Debug module
 parameter DBG_SETS_W = 6;
 
diff --git a/load_store_unit.sv b/load_store_unit.sv
index 9383ad8..c9067b2 100644
--- a/load_store_unit.sv
+++ b/load_store_unit.sv
@@ -23,6 +23,7 @@
 //                                                                            //
 ////////////////////////////////////////////////////////////////////////////////
 
+`include "riscv_config.sv" // Inclure un fichier de configuration pour RISC-V
 
 module riscv_load_store_unit
 (
@@ -67,8 +68,37 @@ module riscv_load_store_unit
 
     input  logic         ex_valid_i,
     output logic         busy_o
+
+`ifdef DIFT // Tags à lire ou écrire
+    ,
+    output logic         data_we_o_tag,       // Activation d'écriture pour les tags
+    output logic         data_wdata_o_tag,    // Données à écrire pour les tags
+`ifdef DIFT_H
+    input  logic [5:0]   data_rdata_i_tag,    // Tags lus
+    output logic [1:0]   data_rdata_ex_o_htag, // Tag hiérarchique demandé lors du load
+`else
+    input  logic [3:0]   data_rdata_i_tag,    // Tags lus
+`endif
+    input  logic         data_we_ex_i_tag,    // Activation d'écriture pour les tags
+    input  logic         data_wdata_ex_i_tag, // Données à écrire pour les tags
+    output logic         data_rdata_ex_o_tag, // Tag demandé
+    input  logic         data_gnt_i_tag,      // Accord de données pour les tags
+    input  logic         data_rvalid_i_tag    // Données valides reçues pour les tags
+`endif
 );
 
+`ifdef DIFT
+  logic         data_we_q_tag;               // Activation d'écriture pour les tags
+`ifdef DIFT_H
+  logic [5:0]   rdata_q_tag;                 // Tags lus
+  logic [2:0]   rdata_offset_q_tag;          // Décalage dans le registre pour les tags
+`else
+  logic [3:0]   rdata_q_tag;                 // Tags lus
+  logic [1:0]   rdata_offset_q_tag;          // Décalage dans le registre pour les tags
+`endif
+  logic [1:0]   data_type_q_tag;             // Type de données pour les tags
+`endif
+
   logic [31:0]  data_addr_int;
 
   // registers for data_rdata alignment and sign extension
@@ -84,7 +114,6 @@ module riscv_load_store_unit
 
   logic         misaligned_st;   // high if we are currently performing the second part of a misaligned store
 
-
   enum logic [1:0]  { IDLE, WAIT_RVALID, WAIT_RVALID_EX_STALL, IDLE_EX_STALL } CS, NS;
 
   logic [31:0]  rdata_q;
@@ -155,12 +184,11 @@ module riscv_load_store_unit
       2'b01: data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};
       2'b10: data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};
       2'b11: data_wdata = {data_wdata_ex_i[ 7:0], data_wdata_ex_i[31: 8]};
-    endcase; // case (wdata_offset)
+endcase; // case (wdata_offset)
   end
 
-
   // FF for rdata alignment and sign-extension
-  always_ff @(posedge clk, negedge rst_n)
+  always @(posedge clk, negedge rst_n)
   begin
     if(rst_n == 1'b0)
     begin
@@ -178,6 +206,27 @@ module riscv_load_store_unit
     end
   end
 
+`ifdef DIFT
+  always @(posedge clk, negedge rst_n)
+  begin
+    if(rst_n == 1'b0)
+    begin
+      data_type_q_tag    <= '0;
+      data_we_q_tag      <= 1'b0;
+      rdata_offset_q_tag <= 1'b0;
+    end
+    else if (data_gnt_i_tag == 1'b1) // request was granted, we wait for rvalid and can continue to WB
+    begin
+      data_type_q_tag    <= data_type_ex_i;
+      data_we_q_tag      <= data_we_ex_i_tag;
+`ifdef DIFT_H
+      rdata_offset_q_tag <= data_addr_int[2:0];
+`else
+      rdata_offset_q_tag <= data_addr_int[1:0];
+`endif
+    end
+  end
+`endif
 
   ////////////////////////////////////////////////////////////////////////
   //  ____  _               _____      _                 _              //
@@ -290,9 +339,7 @@ module riscv_load_store_unit
     endcase //~case(rdata_type_q)
   end
 
-
-
-  always_ff @(posedge clk, negedge rst_n)
+  always @(posedge clk, negedge rst_n)
   begin
     if(rst_n == 1'b0)
     begin
@@ -311,9 +358,9 @@ module riscv_load_store_unit
         // In all other cases, rdata_q gets the value that we are
         // writing to the register file
         if ((data_misaligned_ex_i == 1'b1) || (data_misaligned_o == 1'b1))
-          rdata_q  <= data_rdata_i;
+          rdata_q      <= data_rdata_i;
         else
-          rdata_q  <= data_rdata_ext;
+          rdata_q      <= data_rdata_ext;
       end
     end
   end
@@ -321,12 +368,258 @@ module riscv_load_store_unit
   // output to register file
   assign data_rdata_ex_o = (data_rvalid_i == 1'b1) ? data_rdata_ext : rdata_q;
 
+`ifdef DIFT
+  
+`ifdef DIFT_H
+  assign data_rdata_ex_o_htag = 2'b10;
+  logic [5:0] data_rdata_ext_tag;
+
+  logic [5:0] rdata_w_ext_tag;
+  logic [5:0] rdata_h_ext_tag;
+  logic [5:0] rdata_b_ext_tag;
+
+  always_comb
+  begin
+    case (rdata_offset_q_tag)
+      3'b000: rdata_w_ext_tag = data_rdata_i_tag[5:0];
+      3'b001: rdata_w_ext_tag = {data_rdata_i_tag[0],   rdata_q_tag[5:1]};
+      3'b010: rdata_w_ext_tag = {data_rdata_i_tag[1:0], rdata_q_tag[5:2]};
+      3'b011: rdata_w_ext_tag = {data_rdata_i_tag[2:0], rdata_q_tag[5:3]};
+      3'b100: rdata_w_ext_tag = {data_rdata_i_tag[3:0], rdata_q_tag[5:4]};
+      3'b101: rdata_w_ext_tag = {data_rdata_i_tag[4:0], rdata_q_tag[5]};
+    endcase
+  end
+
+  always_comb // Sélectionner deux bits de tags par rapport à l'offset
+  begin
+    case (rdata_offset_q_tag)
+      3'b000:
+      begin
+        rdata_h_ext_tag = {3'b000, data_rdata_i_tag[1:0]};
+      end
+
+      3'b001:
+      begin
+        rdata_h_ext_tag = {3'b000, data_rdata_i_tag[2:1]};
+      end
+
+      3'b010:
+      begin
+        rdata_h_ext_tag = {3'b000, data_rdata_i_tag[3:2]};
+      end
+
+      3'b011:
+      begin
+        rdata_h_ext_tag = {3'b000, data_rdata_i_tag[4:3]};
+      end
+
+      3'b100:
+      begin
+        rdata_h_ext_tag = {3'b000, data_rdata_i_tag[5:4]};
+      end
+
+      3'b101:
+      begin
+        rdata_h_ext_tag = {3'b000, data_rdata_i_tag[0], data_rdata_i_tag[5]};
+      end
+
+      default:
+      begin
+        rdata_h_ext_tag = 5'b00000;
+      end
+    endcase
+  end
+
+  always_comb // Sélectionner un bit de rdata_q_tag pour rdata_b_ext_tag
+  begin
+    case (rdata_offset_q_tag)
+      3'b00:
+      begin
+        rdata_b_ext_tag = {4'b0000, data_rdata_i_tag[0]};
+      end
+
+      3'b001:
+      begin
+        rdata_b_ext_tag = {4'b0000, data_rdata_i_tag[1]};
+      end
+
+      3'b010:
+      begin
+        rdata_b_ext_tag = {4'b0000, data_rdata_i_tag[2]};
+      end
+
+      3'b011:
+      begin
+        rdata_b_ext_tag = {4'b0000, data_rdata_i_tag[3]};
+      end
+
+      3'b100:
+      begin
+        rdata_b_ext_tag = {4'b0000, data_rdata_i_tag[4]};
+      end
+
+      3'b101:
+      begin
+        rdata_b_ext_tag = {4'b0000, data_rdata_i_tag[5]};
+      end
+
+      default:
+      begin
+        rdata_b_ext_tag = 5'b00000;
+      end
+    endcase
+  end
+
+  always_comb
+  begin
+    case (data_type_q_tag)
+      3'b000:       data_rdata_ext_tag = rdata_w_ext_tag;
+      3'b001:       data_rdata_ext_tag = rdata_h_ext_tag;
+      3'b010,3'b011: data_rdata_ext_tag = rdata_b_ext_tag;
+      3'b100:       data_rdata_ext_tag = rdata_h_ext_tag;
+      3'b101:       data_rdata_ext_tag = rdata_h_ext_tag;
+    endcase
+  end
+
+  always @(posedge clk, negedge rst_n)
+  begin
+    if(rst_n == 1'b0)
+    begin
+      CS            <= IDLE;
+      rdata_q_tag   <= '0;
+    end
+    else
+    begin
+      CS            <= NS;
+      if (data_rvalid_i_tag && (~data_we_q_tag))
+      begin
+        // if we have detected a misaligned access, and we are
+        // currently doing the first part of this access, then
+        // store the data coming from memory in rdata_q.
+        // In all other cases, rdata_q gets the value that we are
+        // writing to the register file
+        if ((data_misaligned_ex_i == 1'b1) || (data_misaligned_o == 1'b1))
+          rdata_q_tag  <= |data_rdata_i_tag;
+        else
+          rdata_q_tag  <= |data_rdata_ext_tag;
+      end
+    end
+  end
+`else
+  logic [3:0] data_rdata_ext_tag;
+
+  logic [3:0] rdata_w_ext_tag;
+  logic [3:0] rdata_h_ext_tag;
+  logic [3:0] rdata_b_ext_tag;
+
+  always_comb
+  begin
+    case (rdata_offset_q_tag)
+      2'b00: rdata_w_ext_tag = data_rdata_i_tag[3:0];
+      2'b01: rdata_w_ext_tag = {data_rdata_i_tag[0],   rdata_q_tag[3:1]};
+      2'b10: rdata_w_ext_tag = {data_rdata_i_tag[1:0], rdata_q_tag[3:2]};
+      2'b11: rdata_w_ext_tag = {data_rdata_i_tag[2:0], rdata_q_tag[3]};
+    endcase
+  end
+
+  always_comb
+  begin
+    case (rdata_offset_q_tag)
+      2'b00:
+      begin
+        rdata_h_ext_tag = {2'b00, data_rdata_i_tag[1:0]};
+      end
+
+      2'b01:
+      begin
+        rdata_h_ext_tag = {2'b00, data_rdata_i_tag[2:1]};
+      end
+
+      2'b10:
+      begin
+        rdata_h_ext_tag = {2'b00, data_rdata_i_tag[3:2]};
+      end
+
+      2'b11:
+      begin
+        rdata_h_ext_tag = {2'b00, data_rdata_i_tag[0], rdata_q_tag[3]};
+      end
+    endcase
+  end
+
+  always_comb
+  begin
+    case (rdata_offset_q_tag)
+      2'b00:
+      begin
+        rdata_b_ext_tag = {2'b00, data_rdata_i_tag[0]};
+      end
+
+      2'b01: begin
+        rdata_b_ext_tag = {2'b00, data_rdata_i_tag[1]};
+      end
+
+      2'b10:
+      begin
+        rdata_b_ext_tag = {2'b00, data_rdata_i_tag[2]};
+      end
+
+      2'b11:
+      begin
+        rdata_b_ext_tag = {2'b00, data_rdata_i_tag[3]};
+      end
+    endcase
+  end
+
+  always_comb
+  begin
+    case (data_type_q_tag)
+      2'b00:       data_rdata_ext_tag = rdata_w_ext_tag;
+      2'b01:       data_rdata_ext_tag = rdata_h_ext_tag;
+      2'b10,2'b11: data_rdata_ext_tag = rdata_b_ext_tag;
+    endcase
+  end
+
+  always @(posedge clk, negedge rst_n)
+  begin
+    if(rst_n == 1'b0)
+    begin
+      CS            <= IDLE;
+      rdata_q_tag   <= '0;
+    end
+    else
+    begin
+      CS            <= NS;
+      if (data_rvalid_i_tag && (~data_we_q_tag))
+      begin
+        // if we have detected a misaligned access, and we are
+        // currently doing the first part of this access, then
+        // store the data coming from memory in rdata_q.
+        // In all other cases, rdata_q gets the value that we are
+        // writing to the register file
+        if ((data_misaligned_ex_i == 1'b1) || (data_misaligned_o == 1'b1))
+          rdata_q_tag  <= |data_rdata_i_tag;
+        else
+          rdata_q_tag  <= |data_rdata_ext_tag;
+      end
+    end
+  end
+`endif
+
+  assign data_rdata_ex_o_tag = (data_rvalid_i_tag == 1'b1) ? |data_rdata_ext_tag : rdata_q_tag;
+`endif
+
   // output to data interface
   assign data_addr_o   = data_addr_int;
   assign data_wdata_o  = data_wdata;
   assign data_we_o     = data_we_ex_i;
   assign data_be_o     = data_be;
 
+`ifdef DIFT
+  assign data_wdata_o_tag = data_wdata_ex_i_tag;
+  assign data_we_o_tag    = data_we_ex_i_tag;
+`endif
+
   assign misaligned_st = data_misaligned_ex_i;
 
   assign load_err_o    = data_gnt_i && data_err_i && data_we_o;
diff --git a/mult.sv b/mult.sv
index ae243ab..9c07bb6 100644
--- a/mult.sv
+++ b/mult.sv
@@ -60,7 +60,7 @@ module riscv_mult
   ///////////////////////////////////////////////////////////////
   //  ___ _  _ _____ ___ ___ ___ ___   __  __ _   _ _  _____   //
   // |_ _| \| |_   _| __/ __| __| _ \ |  \/  | | | | ||_   _|  //
-  //  | || . | | | | _| (_ | _||   / | |\/| | |_| | |__| |    //
+  //  | ||    | | | | _| (_ | _||   / | |\/| | |_| | |__| |    //
   // |___|_|\_| |_| |___\___|___|_|_\ |_|  |_|\___/|____|_|    //
   //                                                           //
   ///////////////////////////////////////////////////////////////
diff --git a/register_file_ff.sv b/register_file_ff.sv
index 7f9e214..0c28b6a 100644
--- a/register_file_ff.sv
+++ b/register_file_ff.sv
@@ -27,8 +27,8 @@ module riscv_register_file
 )
 (
     // Clock and Reset
-    input  logic         clk,
-    input  logic         rst_n,
+    input  logic                   clk,
+    input  logic                   rst_n,
 
     input  logic                   test_en_i,
 
diff --git a/riscv_core.sv b/riscv_core.sv
index 863e074..aadbafa 100644
--- a/riscv_core.sv
+++ b/riscv_core.sv
@@ -84,6 +84,19 @@ module riscv_core
   output logic        core_busy_o,
 
   input  logic [N_EXT_PERF_COUNTERS-1:0] ext_perf_counters_i
+
+`ifdef DIFT
+  ,
+`ifdef DIFT_H
+  input  logic [5:0]  data_rdata_i_tag,
+`else
+  input  logic [3:0]  data_rdata_i_tag,
+`endif
+  input  logic        data_gnt_i_tag,
+  input  logic        data_rvalid_i_tag,
+  output logic        data_we_o_tag,
+  output logic        data_wdata_o_tag
+`endif
 );
 
   localparam N_HWLP      = 2;
@@ -258,6 +271,39 @@ module riscv_core
   logic        perf_jr_stall;
   logic        perf_ld_stall;
 
+`ifdef DIFT
+  logic [31:0] tpr;
+  logic [31:0] tcr;
+`ifdef DIFT_H
+  logic [31:0] thr;
+`endif
+  logic        jump_target_id_tag;
+  logic        jump_target_ex_tag;
+  logic        pc_set_tag;
+  logic        pc_id_tag;
+  logic        regfile_alu_wdata_fw_tag;
+  logic        regfile_alu_we_fw_tag;
+  logic        pc_enable_tag;
+  logic        rs1_tag;
+  logic        exception_tag;
+  logic [ALU_MODE_WIDTH-1:0] alu_operator_mode;
+  logic        alu_operand_a_tag;
+  logic        alu_operand_b_tag;
+  logic        alu_operand_c_tag;
+  logic        data_we_ex_tag;
+  logic        data_wdata_ex_tag;
+  logic        data_rdata_ex_tag;
+  `ifdef DIFT_H
+  logic [1:0]  data_rdata_ex_htag;
+  `endif
+  logic        register_set_tag;
+  logic        is_store_post_tag;
+  logic [4:0]  regfile_alu_waddr_fw_tag;
+  logic [4:0]  regfile_alu_waddr_tag;
+  logic        store_dest_addr_tag;
+  logic        store_source_tag;
+  logic        use_store_ops;
+`endif
 
   //////////////////////////////////////////////////////////////////////////////////////////////
   //   ____ _            _      __  __                                                   _    //
@@ -367,6 +413,13 @@ module riscv_core
 
     .if_busy_o           ( if_busy           ),
     .perf_imiss_o        ( perf_imiss        )
+`ifdef DIFT
+    ,
+    .jump_target_id_i_tag ( jump_target_id_tag ),
+    .jump_target_ex_i_tag ( jump_target_ex_tag ),
+    .pc_set_i_tag         ( pc_set_tag         ),
+    .pc_id_o_tag          ( pc_id_tag          )
+`endif
   );
 
 
@@ -535,6 +588,40 @@ module riscv_core
     .perf_jump_o                  ( perf_jump            ),
     .perf_jr_stall_o              ( perf_jr_stall        ),
     .perf_ld_stall_o              ( perf_ld_stall        )
+`ifdef DIFT
+    ,
+    .regfile_wdata_wb_i_tag       ( data_rdata_ex_tag        ),
+    .regfile_alu_wdata_fw_i_tag   ( regfile_alu_wdata_fw_tag ),
+    .regfile_alu_we_fw_i_tag      ( regfile_alu_we_fw_tag    ),
+    .regfile_alu_waddr_fw_i_tag   ( regfile_alu_waddr_fw_tag ),
+    .tpr_i                        ( tpr                      ),
+    .tcr_i                        ( tcr                      ),
+`ifdef DIFT_H
+    .thr_i                        ( thr                      ),
+    .regfile_wdata_wb_i_htag      ( data_rdata_ex_htag       ),
+`endif
+    .pc_id_i_tag                  ( pc_id_tag                ),
+    .pc_enable_i_tag              ( pc_enable_tag            ),
+    .rs1_i_tag                    ( rs1_tag                  ),
+    .exception_i_tag              ( exception_tag            ),
+    .jump_target_o_tag            ( jump_target_id_tag       ),
+    .pc_ex_o_tag                  (                          ),
+    .pc_set_o_tag                 ( pc_set_tag               ),
+    .alu_operator_o_mode          ( alu_operator_mode        ),
+    .store_dest_addr_ex_o_tag     ( store_dest_addr_tag      ),
+    .store_source_ex_o_tag        ( store_source_tag         ),
+    .use_store_ops_ex_o           ( use_store_ops            ),
+    .alu_operand_a_ex_o_tag       ( alu_operand_a_tag        ),
+    .alu_operand_b_ex_o_tag       ( alu_operand_b_tag        ),
+    .alu_operand_c_ex_o_tag       ( alu_operand_c_tag        ),
+    .check_s1_o_tag               ( check_s1_tag             ),
+    .check_s2_o_tag               ( check_s2_tag             ),
+    .check_d_o_tag                ( check_d_tag              ),
+    .register_set_o_tag           ( register_set_tag         ),
+    .is_store_post_o_tag          ( is_store_post_tag        ),
+    .memory_set_o_tag             ( memory_set_tag           ),
+    .regfile_alu_waddr_ex_o_tag   ( regfile_alu_waddr_tag    )
+`endif
   );
 
 
@@ -609,6 +696,33 @@ module riscv_core
     .ex_ready_o                 ( ex_ready                     ),
     .ex_valid_o                 ( ex_valid                     ),
     .wb_ready_i                 ( lsu_ready_wb                 )
+`ifdef DIFT
+    ,
+    .alu_operator_i_mode        ( alu_operator_mode            ),
+    .alu_operand_a_i_tag        ( alu_operand_a_tag            ),
+    .alu_operand_b_i_tag        ( alu_operand_b_tag            ),
+    .alu_operand_c_i_tag        ( alu_operand_c_tag            ),
+    .data_we_ex_i               ( data_we_ex                   ),
+    .check_s1_i_tag             ( check_s1_tag                 ),
+    .check_s2_i_tag             ( check_s2_tag                 ),
+    .check_d_i_tag              ( check_d_tag                  ),
+    .register_set_i_tag         ( register_set_tag             ),
+    .is_store_post_i_tag        ( is_store_post_tag            ),
+    .memory_set_i_tag           ( memory_set_tag               ),
+    .store_dest_addr_i_tag      ( store_dest_addr_tag          ),
+    .store_source_i_tag         ( store_source_tag             ),
+    .use_store_ops_i            ( use_store_ops                ),
+    .regfile_alu_waddr_i_tag    ( regfile_alu_waddr_tag        ),
+    .regfile_alu_wdata_fw_o_tag ( regfile_alu_wdata_fw_tag     ),
+    .regfile_alu_we_fw_o_tag    ( regfile_alu_we_fw_tag        ),
+    .regfile_alu_waddr_fw_o_tag ( regfile_alu_waddr_fw_tag     ),
+    .jump_target_o_tag          ( jump_target_ex_tag           ),
+    .pc_enable_o_tag            ( pc_enable_tag                ),
+    .data_wdata_ex_o_tag        ( data_wdata_ex_tag            ),
+    .data_we_ex_o_tag           ( data_we_ex_tag               ),
+    .rs1_o_tag                  ( rs1_tag                      ),
+    .exception_o_tag            ( exception_tag                )
+`endif
   );
 
 
@@ -664,6 +778,21 @@ module riscv_core
 
     .ex_valid_i            ( ex_valid           ),
     .busy_o                ( lsu_busy           )
+`ifdef DIFT
+    ,
+    .data_we_o_tag         ( data_we_o_tag      ),
+    .data_wdata_o_tag      ( data_wdata_o_tag   ),
+    .data_rdata_i_tag      ( data_rdata_i_tag   ),
+    .data_we_ex_i_tag      ( data_we_ex_tag     ),
+    .data_wdata_ex_i_tag   ( data_wdata_ex_tag  ),
+    .data_rdata_ex_o_tag   ( data_rdata_ex_tag  ),
+    .data_gnt_i_tag        ( data_gnt_i_tag     ),
+    .data_rvalid_i_tag     ( data_rvalid_i_tag  )
+    `ifdef DIFT_H
+    ,
+    .data_rdata_ex_o_htag  ( data_rdata_ex_htag )
+    `endif
+`endif
   );
 
   assign wb_valid = lsu_ready_wb;
@@ -740,6 +869,15 @@ module riscv_core
     .mem_store_i             ( data_req_o & data_gnt_i & data_we_o    ),
 
     .ext_counters_i          ( ext_perf_counters_i                    )
+`ifdef DIFT
+    ,
+    .tpr_o                   ( tpr                                    ),
+    .tcr_o                   ( tcr                                    )
+`ifdef DIFT_H
+    ,
+    .thr_o                   ( thr                                    )
+`endif
+`endif
   );
 
   // Mux for CSR access through Debug Unit
diff --git a/src_files.yml b/src_files.yml
index 621a43d..f1f79bb 100644
--- a/src_files.yml
+++ b/src_files.yml
@@ -7,22 +7,30 @@ riscv:
     include/riscv_tracer_defines.sv,
     alu.sv,
     alu_div.sv,
+    check_tag.sv,
     compressed_decoder.sv,
     controller.sv,
     cs_registers.sv,
     debug_unit.sv,
     decoder.sv,
+    enable_tag.sv,
     exc_controller.sv,
     ex_stage.sv,
+    hierarchy_check.sv,
     hwloop_controller.sv,
     hwloop_regs.sv,
     id_stage.sv,
     if_stage.sv,
+    load_propagation.sv,
+    load_check.sv,
     load_store_unit.sv,
+    mode_tag.sv,
     mult.sv,
     prefetch_buffer.sv,
     prefetch_L0_buffer.sv,
     riscv_core.sv,
+    tag_propagation_logic.sv,
+    tag_check_logic.sv,
   ]
 riscv_vip_rtl:
   targets: [
@@ -44,6 +52,7 @@ riscv_regfile_rtl:
   ]
   files: [
     register_file.sv,
+    register_file_tag.sv,
   ]
 riscv_regfile_fpga:
   targets: [
@@ -54,5 +63,5 @@ riscv_regfile_fpga:
   ]
   files: [
     register_file_ff.sv,
+    register_file_ff_tag.sv,
   ]
-
